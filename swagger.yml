---
openapi: 3.0.1

servers:
  - url: https://sender.api.kivra.com
    description: Production environment
  - url: https://sender.sandbox-api.kivra.com
    description: Sandbox environment
info:
  title: Kivra Sweden API
  x-logo:
    url: "assets/Kivra_logo_1920X1080_green.png"
    altText: Kivra logo # don't rename this without fixing assets/redoc-styles.css
  version: v1 and v2
  description: |
    # Receipt API
    The Receipt API, used to send digital receipts to users in Kivra, is available [here](http://developer.kivra.com/receipt/posapi/index.html).

    # Introduction
    This document is intended for developers and others who are interested in integrating with [Kivra Sweden](https://www.kivra.se) to send digital mail. Questions can be sent to [avsandare.support@kivra.com](mailto:avsandare.support@kivra.com) or via [our contact form](https://kivra.se/sv/foretag/skicka/hjalp).
    If anything is missing or seems incorrect, please check the [GitHub issues](https://github.com/kivra/developer.kivra.com/issues) for existing known issues or [create a new issue](https://github.com/kivra/developer.kivra.com/issues/new).

    ## National versions of Kivra APIs
    As local requirements and regulations might affect the way one interacts with the API, it's important to look for the version of the Kivra API specific for the Country where you intend to operate.

    This version of the API is about **Kivra Sweden**.

    ## Api version: v1 and v2
    We currently have some endpoints in v1 and some endpoints in v2. Each endpoint documented here specifies in the URL whether the endpoint requires v1 or v2.

    Authentication is the same for both v1 and v2.

    ## Introduction to API integration
    The Kivra API is organized around [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer). Our API has predictable,
    resource-oriented URLs, and uses HTTP response codes to indicate API errors.

    Integration in its simplest form consists of two steps:

      1. The first step is to match the Recipient-databases either as a whole or one by one and see which Recipients the tenant can send contents to
      2. The second step is to send the contents itself.

    A prerequisite for these two steps is to have client credentials, to be authorized to use the Kivra API, and a tenant ID to specify who is the sender of the content.


    ## The service
    Kivra is a secure digital mailbox tied to your social security number or
    VAT-number to which you receive documents from companies, organizations
    and government agencies that are connected to Kivra. With Kivra you can
    receive, manage and archive your content wherever you are and on every
    platform as long as you have an internet connection.

    Over one billion window envelopes are sent every year in Sweden alone, so
    by choosing to use Kivra you contribute to a reduced carbon footprint!

    Kivra acts as a digital postman between Sender and Recipients which is
    also reflected in the allocation of responsibilities. Concretely, this
    means that the Sender is responsible for the design and content whereas
    Recipients are responsible for reading and processing the received content.

    ## Policy for Personal Information in the metadata
    It is not allowed to include so called sensitive personal data in any of the free-text metadata fields.

    Sensitive personal data includes the data referred to in article 9.1. GDPR (data concerning racial or ethnic origin,
    political opinions, religious or philosophical beliefs, membership of a trade union, health, a person's sex life or
    sexual orientation, genetic data, biometric data that is being used to uniquely identify a person), and this means
    for example that it is not allowed to state the reason for a booking in either of the Title field or the Description
    field when sending medical care notices.

    The sender is responsible for ensuring no sensitive personal data is included in any of the free-text metadata fields.

    # Change Mangement
    The Kivra API is continuously improved and new features may be added at any time. Major changes are announced
    via the [KivraStatus](https://www.kivrastatus.se) service.

    Disruptive changes in the API that may break existing integrations, as for instance removal of an older version of an API endpoint, are announced via [KivraStatus](https://www.kivrastatus.se) at least 6 months before the change becomes operative.

    We strongly recommend to subscribe to [KivraStatus](https://www.kivrastatus.se) in order to get updates for the API.

    ## Changelog
    List changes to the API documentation.

    | Date         | Details of changes 2    2                                          |
    | ------------ | ------------------------------------------------------------------ |
    | 2016-10-14 | Release of Kivra API Version 1                                     |
    | 2018-04-20 | Clarify [Environments and API Endpoints](#api-endpoints)           |
    | 2018-04-27 | Document optional Content-fields and response-headers              |
    | 2018-08-20 | Added description of `partner` endpoint (BETA).                    |
    | 2018-08-20 | Correction in Company scheme                                       |
    | 2019-04-30 | Added Tenant Agreement API as (BETA) |
    | 2019-05-10 | Added `variable_amount`and `min_amount`in Payment scheme |
    | 2019-05-10 | Removed deprecated `token` bearer. `Bearer` should be used instead |
    | 2019-06-04 | Added Tenant API v2 |
    | 2019-08-08 | Updated size for icons and agreement schema |
    | 2019-09-05 | Multiple Examples for content, removed TelNumber from AgreementParty  |
    | 2019-09-23 | v1 and v2 description. Corrections in the agreement endpoints. Agreements now available in production. |
    | 2020-01-08 | Removed v1 of POST tenant |
    | 2020-03-31 | Announcing of new endpoints and removal of old ones in 6 months |
    | 2020-07-07 | New layout and text adjustments |
    | 2020-09-28 | "type" attribute in content schema |
    | 2021-10-14 | Endpoint `/v1/tenant/{tenantKey}/user/diff/{diffId}` |
    | 2022-02-25 | New error codes |
    | 2022-03-15 | Information about PAdES release for Kivra Signatures |
    | 2022-04-11 | More details about specification for time and dates |
    | 2022-07-11 | Added state `generating` for agreements |
    | 2022-09-09 | Added v2 of tenant/TKEY/content endpoint |
    | 2022-12-02 | Added Forms BETA endpoints for Sandbox. API not stable. Breaking changes may happen.  |
    | 2023-03-08 | Added v3 of the company Partner API |

    # Terminology
    ### User
    An end user who is a user of Kivra and receives Content from tenants. A user is a physical person.
    Users are required to login at least once every 12 month to be considered active. A user that has not logged in since longer than 12 months will no longer be listed for matching to inform the tenant that they should not send content to this user.
    A user can also become `dormant` or deactivate themselves and be put under a `grace period`. Both these states are to aid the Tenant in making sure that only active Users are available for receiving Content.
    See below for more information on Dormant and Grace period.

    ### Company
    A Company is a judicial person that can receive content from tenants. Users that are signatories to the company have access to the company’s mailbox and archive. Other Users that are not signatories may also be given access to a company’s mailbox and archive. A Company can become `dormant` or deactivated by users that are signatories to the company. Both these states is to aid the Tenant in making sure that only active Companies are available for receiving Content. See below for more information on Dormant and Grace period.

    ### Non-user
    A non-user is an individual who is not a customer of Kivra but could be addressed by tenants in specific flows like the *retain functionality* or *signatures*.

    ### Recipient
    A Company, a User or a non-user in the context of being a receiver. Throughout this document Recipient is used to interchangeably mean a User or Company being a receiver.

    ### Tenant / Integrator
    Tenant is a sender that is integrated with Kivra. They need not be integrated directly, but can go through an integrator. The integrator acts as intermediary for the tenant at integration and can handle multiple tenants.

    ### Partner
    Partner is a third-party company (typically an ERP company) that may be granted access to access and process a company's mailbox, on behalf of the company.

    ### Content
    The information sent by Tenants to Recipients, i.e. Documents, Invoices, etc.

    ### Dormant Recipient
    Recipient who can’t be reached by email and sms-notifications are put in a "dormant"-state. During this dormant state the Recipient won’t show up in any of user or company matching functionalities but the Tenant can still send Content which the Recipient will receive. When a Recipient log-in again they are awaken from dormant state and will start appearing in the matching functionalities again.

    ### Grace period
    Kivra employs a `45` day grace period when a Recipient deactivates. During this grace period the Recipient won’t show up in any of user or company matching functionalities but the Tenant can still send Content which the Recipient will receive.

    ### User object
    is a data object that contains all the available information about a user

    ### Company object
    is a data object that contains all the available information about a company

    ### Tenant object
    is a data object that contains all the available information about a sender.

    ### Content object
    is a data object that contains information about the document and the document itself

    ### Retained functionality
    For tenants wishing to send content to Recipients who are at the time not existing in Kivra’s database.
    Kivra will then store the content for the agreed period of time and deliver it once/if the target Recipient
    registers with Kivra within this period of time.

    <aside class="notice">
    Note: Usage of retained functionality is only allowed for documents of type credit notice and salary slip.
    </aside>

    ### Tenant key
    Is a unique key that identifies a Tenant.

    ### Metadata
    is data about data or information about data. Originally, the concept of meta-information, ie information about information. Normally metadata describes the content and / or structure for a given data collection from any perspective. Kivra uses metadata to determine whom a content is to be sent to and other information that may be relevant for a shipment, as for instance payment information.

    ### Json
    Json or JavaScript Object Notation is a structured approach to data management. Similar to XML but much simpler and easier to read. JSON is the default serialization format  within the Kivra system. JSON have a limited set of types and close attention needs to be paid to the correct JSON-type for metadata when sending Content to Kivra.

    # Conventions
    ## Date & Time
    KIVRA encodes and decodes all dates and times as [ISO 8601](http://www.w3.org/TR/NOTE-datetime) values. The format looks like `YYYY-MM-DDThh:mm:ss.sTZD`, example `1970-01-01T23:25:10.0330000+01:00` where:

    * `YYYY`, The year including century
    * `MM`, Month
    * `DD`, Day
    * `T`, Separator
    * `hh`, Zero-padded hour between `00` and `24` (where `24` is only used to notate midnight at the end of a calendar day)
    * `mm`, Zero-padded minutes between `00` and `59`
    * `ss`, Zero-padded second between `00` and `60` (where `60` is only used to notate an added leap second)
    * `s`, one or more digits representing a decimal fraction of a second
    * `TZD`, Time zone designator (`Z` or `+hh:mm` or `-hh:mm`)

    ## UTC
    If the time is in UTC, add a `Z` directly after the time without a space. `Z` is the zone designator for the zero UTC offset. `09:30 UTC` is therefore represented as `09:30Z` or `0930Z`. `14:45:15 UTC` would be `14:45:15Z` or `144515Z`. UTC time is also known as 'Zulu' time, since 'Zulu' is the NATO phonetic alphabet word for `Z`.

    The offset from UTC is given in the format `±[hh]:[mm]`, `±[hh][mm]`, or `±[hh]`. So if the time being described is one hour ahead of UTC (such as the time in Stockholm during the winter), the zone designator would be `+01:00`, `+0100`, or simply `+01`. This is appended to the time in the same way that `Z` was above. The offset from UTC changes with daylight saving time, e.g. a time offset in Chicago, would be `-06:00` for the winter (Central Standard Time) and `-05:00` for the summer (Central Daylight Time).

    Please note that we always expect date & time to be specified as UTC or having an explicit timezone. Time & date fields without any time zone designator will be interpreted as UTC.

    ## Media types
    The [IANA](http://www.iana.org/assignments/media-types/media-types.xhtml) media types, e.g. "application/pdf"

    ## UTF-8 encoding
    All data sent to Kivra needs to be [UTF-8](http://en.wikipedia.org/wiki/UTF-8) encoded.

    ## Currency
    All places where currency is specified, [ISO4217](https://en.wikipedia.org/wiki/ISO_4217) should be used.

    ## Country code
    Where applicable KIVRA uses a country code to determine certain formats. The country code should always be supplied using the [ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) alpha-2 two-letter code.

    ## Email address
    Email addresses needs to be specified using [E.123](https://en.wikipedia.org/wiki/E.123)

    ## Phone numbers (mobile, land line)
    All phone numbers needs to be specified using [E.123](https://en.wikipedia.org/wiki/E.123)

    ## Identifying users
    Kivra uses the social security number/personal-number as key when accepting content. The format must adhere to the format `YYYYMMDDnnnn` that is including century-digits, i.e. `191212121212`.

    ## VAT identifier
    In many countries, companies (or even individuals) are registered with authorities responsible for collecting taxes derived from the business transactions performed by the companies. That registration commonly yields a registration number, which uniquely identifies that company within the domain of the authority. Some legislation has a concept of VAT grouping, in which case the structure of the VAT identifier may reflect the grouping by e.g. suffixing the number.

    The full identifier starts with an ISO 3166-1 alpha-2 country code (except for Greece which uses the non-standard country code EL) and then has between `2` and `12` characters. The identifiers are composed of numeric digits in most countries, but in some countries they may contain letters.

    Kivra only uses and recognizes the Swedish VAT number which is composed of the prefix `SE` followed by 12 digits. For instance, Kivra’s VAT Id would be: `SE556840226601`.

    # Limits
    Kivra handles millions of documents. We put limits to protect the system from receiving more data than it can handle, and to ensure an equitable distribution of system resources. There’s also various practical reasons for this, such as reducing Head-of-line blocking and providing a optimal experience for the enduser.

    Our policies are as follows and are subject to change.

    ### Content File-size
    `1 MB` per **Content** per **Recipient**. This is the total JSON-object. For example, if you send two PDF’s embedded in a JSON-Content to a User the total for the JSON have to have a size less than `1 MB`.

    ### Rate limit
    `50` **contents** to the same **recipient** per minute. You can send many more contents per minute as long as they are to different receivers, but only up to `50` to the same recipient.

    ### Payload size
    Unless specified otherwise the payload for all requests have a max limit of `10MB`. Requests with payload larger than the max size will be rejected with error 413.

    # Interacting with the API
    All API access is performed over HTTPS through sender.[api, sandbox-api].kivra.com and data is sent and received as [JSON](http://www.json.org/). For trying out the API without touching live data we’ve set up a sandbox environment.
    In order to ensure data privacy the following choices have been made, to name some that directly impact API workflows:
    Unencrypted HTTP is not supported, you will be redirected to the resource you tried to reach, with http replaced by https, if you attempt to use plain HTTP.
    Resources you have no right to see will either give you a describing status code or a `404`. `404` statuses are returned if the case is such that you don’t even have the right to know, according to the system's current state, if an object exists.

    ## API Endpoints
    Kivra uses different endpoints for production and testing as described below. We also provide the current IP addresses that *could* serve API requests, the current DNS-record will provide an up-to-date list with active endpoints. This is not meant to be a complete list of Kivra-maintained IP addresses. Please make sure to **always** access the Kivra API using the correct domain-name and environment instead of relying on IP addresses.

    Kivra maintains a infrastructure, which grows dynamically to accommodate increasing demand. As a result, Kivra API servers use a range of IP addresses, and the addresses often change.

    *Please note that we do not recommend managing firewall restrictions by IP address, as the IPs associated with these domains are not static.*

    <aside class="notice">
    All interaction with Kivra's APIs must be done over HTTPS.
    </aside>

    ### Production environment
    The API endpoint for the production environment can be found at

    `https://sender.api.kivra.com`

    The production environment should only be used for sending real data, not for testing of any sort. For testing, please refer to Sandbox.

    ### Sandbox environment
    The API for the sandbox environment can be found at

    `https://sender.sandbox-api.kivra.com`

    The sandbox is not to be used with any critical or production data. We make no guarantees as to the availability of the service, or the data stored by it.

    We usually deploy the latest production environment to our Sandbox, but may occasionally update it with newer builds, which may not be as reliable or well tested.

    The Sandbox environment cannot be used for capacity or volume tests as it has a much smaller capacity and performance than our production environment.

    ## URL Components
    When constructing resource identifiers (URIs) it is best to consider them as being built with up to four discrete units.

    ### Endpoint
    `https://sender.TYPE.kivra.com`

    ### Version
    `/VERSION`

    ### Tenant resource
    `/tenant/TENANTKEY`

    ### Parameters
    `/?QUERYSTRING`

    ## Unit Fields
    The units have parameterized fields, which allow you to change their respective meanings, those fields are briefly described below.

    ### TYPE
    `sandbox-api` for development and test or `api` for production purposes.

    ### VERSION
    Current API version is `v1` but some endpoint are already available as `v2`

    ### KEY
    The identifier of an object in a collection, its ID, if you will.

    ### QUERYSTRING
    A set of key-value pairs, used for filtering and setting options on collections.

    ## HTTP Verbs
    Where possible, the KIVRA API strives to use appropriate HTTP verbs for each action. The terms verb and method are used interchangingly.

    ### Idempotency
    The API supports idempotency for safely retrying requests without accidentally performing the same operation twice. For example, if a request that is idempotent fails due to a network connection error, you can safely retry the request.

    `GET` and `DELETE` requests are idempotent by definition, meaning that the same backend work will occur no matter how many times the same request is issued. You shouldn't send an idempotency key with these verbs because it will have no effect.

    In short, this means that making a request with an idempotent verb only changes the state of the data the first time the request is made.

    ## Methods
    Read more about [HTTP/1.1 Method Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html).

    | Method      | Details                                                    |
    | ----------- | ---------------------------------------------------------- |
    | GET         | Used to read a resource, be it a collection or an object. That is, it can be performed repeatedly without changing the state of the resource |
    | POST        | Used for creating resources, or performing custom or batch type actions |
    | PUT         | Used for updating resources or collections, but can also be used to create a resource when the key has been predetermined. Note that `PUT` apply to the entire resource and not just parts of it. So, when doing a `PUT` operation, the entire resource is replaced |
    | DELETE      | Used for deleting resources. Delete is atomic and acts on the whole resource, that is it can not be used to delete a part or alter the state of a resource. Use `PUT` for that |

    # Resource Types
    There are two main types of resources – objects and collections of objects, they are individually outlined in the following sections.
    It can generally be said that if a URL ends with a unique identifier (also known as a key), it is an object or a sub-object. Resources ending with collection names are collection resources.

    ## Object Resources
    Objects are mostly real-world things, such as a user, tenant to name a few, but they can also be abstract things, like a sendrequest.

    An example: */v1/tenant/13443459078e31ba8630e2e9842906c7baf38b131e*

    ### Allowed Methods
    **GET**
    Read the representation of an object as it is accessible and viewable by you.

    **PUT**
    Update the object. If the object doesn’t already exist, it is created.

    **PATCH**
    Update the object with the specified attributes.

    **DELETE**
    Irreversably delete the designated resource from the entire system. This operation will in most cases be illegal for regular API consumers.

    ## Collection Resources
    Collections are conceptually lists of objects, that can be queried. Queries without any parameters will cause a listing of the keys that are used to identify the objects within the collection; adding parameters will either filter which keys show up or decorate the keys with the object they identify (in part or entirely).

    When a collection resource is queried it will only return the list of keys that identify the objects it contains. If you want to see the actual objects you have to append the query parameter include=body to the URI, more on this below.

    An example: */v2/tenant*

    ### Allowed Methods
    **GET**
    List objects under the Collection, either all or using filters to search.

    **POST**
    Create a new object under the Collection.

    ## Filters and Flags
    In order to facilitate filtering/searching amongst the API objects, we provide the possibility to pass certain query string parameters that indicate which objects to include in the response and how they should be treated.

    ### Filters
    When searching for an object, it is suggested that you list the appropriate collection and add query parameters for the features of the object(s) you are trying to find in the URI. For example, when looking for if a user exists and is addressable for this Tenant, the resulting URL would be as follows `/tenant/TKEY/user/?ssn=SSN`

    ### Flags
    As mentioned, collections only list the keys of their member objects, which might inconvenience you by forcing you to make individual GET requests for each key in the list. In order to not waste bandwidth or time from setup and teardown of connections we supply the include flag. The include parameter currently accepts one of two values, body and fields, which indicate that you want the entire object or that you want a specific subset of the available fields, respectively.

    **Note:** When the include parameter is set to fields it is assumed that you will also pass a fields parameter with a comma-separated list of names, declaring which fields you want to view.

    # Tenants integration: Content management

    Tenants integration allows *tenants* and *integrators* to send *content* to *recipents* via Kivra.

    Tenants and integrator will use the `tenant` endpoint to integrate with Kivra.

    Before looking at the details of the integration, let's look at the concept of "opt-out" and its implication for tenant integration.

    ## Opt-out
    Kivra uses a method called opt-out to make the service as easy as possible for Recipients and Senders. Opt-out means that when a Recipient register with Kivra they’ll automatically receive documents from all Tenants connected to Kivra. Recipients do not need to enable individual Tenants to start receiving Content.

    ### Meaning of Opt-out for:

    #### Tenant

    Tenants can start sending Content to all Recipients in Kivra.

    When Tenant signs up new customers they can check (match) if that `SSN` or `VAT`-number is available as recipient in Kivra. If so, they can start sending content to them directly.

    A Recipient can choose to disable (opt-out) a Tenant. In that case, that user or company will no longer show up as available in Kivra for that tenant. A `45`-day grace period will start to take effect to allow tenants to match their register. During this grace period the Tenant can still post content to the recipient.

    #### Recipients

    Recipients will automatically start receiving Content from new Tenants.

    Recipients can choose to disable (opt-out) a Tenant. In that case, that Recipient will no longer show up as available in Kivra for that tenant. A `45`-day grace period will start to take effect to allow tenants to match their register. During this grace period the Tenant can still post content to the recipient.

    Recipients needs to login at least once every 12 months to be considered active, and show up as available for the tenants.

    ## Typical flow for content management

    The typical flow for sending content to recipients is illustrated here:

    ![Send Content to Kivra - Basic Flow](https://www.lucidchart.com/publicSegments/view/3774eaa4-e877-49e8-86d3-0470f95f9b05/image.png)

    ## Step 1: Matching Recipients

    An integration starts by matching which Recipients can receive Content from the Tenant. Trying to send Content to Recipients not available to that tenant (either because they are not Kivra users or because they opt-out from that tenant) will be denied unless that Recipient is in a `45` days’ grace period with that Tenant.

    This means that for each Tenant the Recipient-request is unique and therefore integrators managing several Tenants need to keep track of the different Recipients for each of the Tenants.

    Matching of recipients is done via the `usermatch` resource.

    Matching of recipients is strongly recommended with the exception of flows using the "retain" functionality.

    ## Step 2: Send Content

    Sending of Content is done via the `content` resource. The metadata in the `content` resource identifies the user and also determines how the recipient can interact with the content.

    ## Typical integration flows

    The Kivra API is typically integrated in different data flows, resulting in many different scenarios. In this paragraph we will describe few of these typical scenarios and provide some tips on how to use the API in that context.

    ### Daily document sending

    In this scenario the sender needs to send a large amount of documents each day, some of which is sent via Kivra, the rest via ordinary post. There is therefore need for knowing very early in the process whether a document can be sent via Kivra or needs to be printed and sent by ordinary post.

    The sender uses the API to match the recipient database, typically during the night, and use the recipient database to select which documents to be sent via Kivra and which need to be printed and sent via ordinary post.

    Even if the recipient database have been matched, it is still important to check the result of the API operation when sending content, as some recipient might have become unavailable in the time between the matching of the recipient database and the sending of the document. In this case the API will answer with an error code (typically `40105`). The documents that could not be sent via API will need to be sent via ordinary post, typically as part of tomorrow's batch.

    ### Payslips and retain functionality

    Payslips are typically small batches of documents sent once a month that can be handled using a simpler flow, not including the matching step but using the retain functionality instead.

    In this approach the sender sends all documents without checking if the user is a Kivra user or not, relying on the retain functionality instead. Content sent to non-Kivra users will be retained for a period of time (typically `390` days for payslips), meaning that it is kept by Kivra but not delivered. If the user creates a Kivra account before the retention period expires, the user will get all retained content. If the user does not create a Kivra account before the retention period expires, the content will be removed from Kivra.

    ### Payments and invoices

    Kivra allows to send both payable invoices (that might be paid via Kivra applications) or payment notifications that cannot be paid via Kivra, as for instance notification of autogiro payments.

    `payable` is the field in the metadata controlling whether the document should be payable via Kivra applications or not. As Kivra uses the information provided in the metadata to actually perform the payment, it is very important that metadata in the `payment` section is correct.

    Invoices can have multiple payment options. That means that while the recipient of the payment is the same for the entire invoice, some specifics of the payment can vary. The details are described further down in this document, but in general each option can have its own amount, reference information and due date. If there are more than one option, each of them must have a short title, and may have a longer description as well as its own icon.

    If an invoice has more than one payment option, the first option is treated specially. All notifications are based on the due date in the first option, and if a user accesses an invoice in an older client that is not aware of the multiple-option functionality, it will only display the information from the first option. Because of this, it is important that the first option always is to pay the entire debt, or, more generally, that paying the first option will release the user from any further obligation related to that particular invoice.

    If there are between one and seven payment options, there may also be a _flexible option_. This is meant to present the payer with the opportunity to choose how much they want to pay, within given limits. It is given specially under the key `flexible_option` rather than included in the normal options list. The object under the key shares some options with normal options, but does not specify a specific amount. Instead it has four optional keys giving mandatory and suggested limits for the lowest and highest amounts to be paid. Suggested limits will be used by the clients for prompting, hard limits will be enforced by both clients and backend.

    # Tenant integration: Tenant management

    With the introduction of `v2` of the Tenant management API, the client has the possibility to manage the tenants programmatically. In more details the client may:

    * Create a tenant
    * List all tenants that the client has currently access to
    * Update and manage which companies the tenant represents
    * Manage and update the display information of a tenant, meaning the sender name and the icon displayed in the Kivra apps to represent the sender
    * Request access to a tenant that is currently managed by some other client

    # Tenant integration: Agreements

    Agreements integration allows *tenants* and *integrators* to send content to be signed via Kivra's signature service. Content to be signed is sent to a list of receivers (signers or delegates, see below) who may login to [signatures.kivra.com](https://signatures.kivra.com/), identify themselves and sign the document via BankId. Upon signature by all parties, the agreement is completed and a new content is created (the covenant file, see below) including the original content plus a signing log listing all signers and information about the signature. Covenant files can be verified cryptographically to make sure that the information included (both original content and signing log) is correct and has not been altered after creation.

    Kivra's agreement service is not directly connected to Kivra's mailbox, and parties in an agreement do not need to be users of Kivra to use the service. However signers that are users of Kivra (or become Kivra users during the signing process) will have the benefit that the covenant file will be automatically transferred to their mailbox once the agreement is signed.

    ## Signers, Delegates and Parties

    Each individual signer in an agreement is categorized as either `signer`or `delegate`:

    * a `signer` signs an agreement as an individual, for instance in the scenario of an employment agreement, the `signer` is the person receiving an employment offer. Each agreement must have at least one `signer`. Signer(s) do not need to be users of Kivra.
    * a `delegate` signs an agreement as representative for a company, for instance in the scenario of an employment agreement the `delegate` is typically the HR manager sending the employment offer. To have a `delegate` in an agreement is not mandatory, in case the agreement only requires to be signed by the signer(s). Delegate(s) do not need to be users of Kivra.
    * 'parties' refers to the `signers` and `delegates` in an agreement.

    ## Agreement states

    During its lifetime, an agreement can go through various states. The current state can be accessed by getting the agreement via the signature API:

    ### State active

    This is the inital state of the agreement after a successful create. During user actions on the agreement the state remains as `active`. The states that an active agreement can transition to are referred to as *terminal* states, meaning it's the end of the agreement lifecycle.

    If an agreement do not transition to a terminal state within 30 days from its creation, it will expire and it will be removed from all our services.

    ### State generating

    When the last of all parties sign the agreement, the agreement transition to state `generating` while the covenant PDF is generated
    and all necessary operations required for PAdES are applied to it. The `generating` state will then automatically transition to `completed`
    as soon as the covenant file is ready.

    ### State completed

    Agreements automatically transitions to the state `completed` at the time when the last of all parties sign the agreement and the covenant file is ready. When an agreement has been completed, it is forever under the terminal state completed and can never transition back to an active state or be acted upon by any party. In other words, no one can change a completed agreement.

    When an agreement becomes completed, a covenant file is created (see below). The covenant file will be availabe to the tenant via the signature API, and to the signers and delegates via the graphical interface.

    No one can change a signed agreement and the agreement along with all data and files relating to the agreement will be completely removed from all our services after `30` days from the date it became completed.

    ### State revoked

    This state can be triggered by a tenant who owns the agreement. If the agreement is *active*, the tenant can choose to revoke the agreement at any time. When an agreement has been revoked, it is forever under the terminal state revoked and can never transition back to an active state or be acted upon by any party. No one can sign a revoked agreement and the agreement along with all data and files relating to the agreement will be completely removed from all our services within `30` days after the date it was created.

    ## Agreement verification and covenant file

    When the agreement transitions to the `completed` state, a few more things happen. An additional PDF file, a signed version of the original agreement, is created. This file is called the `covenant file`. The covenant file includes the original agreement and some additional pages including Bank ID data for the signatures and additional information about the signing events. The covenant file is accessible for `30` days to the tenant and all parties, after that it is removed from all services, together with the initial descriptive data for the original agreement. However, we construct a new data structure that we store persistently and that will be used for verification: a `256bit` string value constructed through an internal algorithm that we refer to as `verification value`.

    The verification value is used solely for verification purposes. This means that if you have access to the signed document, you can use this for verification through our services where we run the obtained file through our internal algorithm to produce the value string for that exact file.

    Since 2022-03-15 the covenant file is also digitally signed according to PAdES (PDF Advanced Electronic Signatures). PAdES is a standard for digital signatures which is adopted by the European eIDAS standard, meaning that agreements signed according to PAdES are legally binding in all EU member states since July 2014. For more information on PAdES: [Wikipedia article](https://en.wikipedia.org/wiki/PAdES) or [EU e-Signature page](https://ec.europa.eu/digital-building-blocks/wikis/display/CEFDIGITAL/Standards+and+specifications). This means that covenant PDFs produced by Kivra Signatures are self-bearing and their validity and authenticity can be easily determined by free PDF readers like Abobe Acrobat Reader, completely independently of Kivra. The PAdES signature can also be verified programmatically if one would like to do so.

    For more information on how we handle PDF files in Kivra Signatures and PAdES, please refer to [this document](https://docs.google.com/document/d/1OFBI3wa1iDxzGrbXY0o1HMavGJCLrNCU2Pt-1EdQTmI/edit?usp=sharing).
    ## Notifications

    After creating the agreement, the tenant is responsible to inform the parties that there is a document waiting to be signed at [signatures.kivra.com](http://signatures.kivra.com/).
    After the users access the Kivra signature service and agree to its terms of service, Kivra will notify signers when the document has been signed by all and is ready to be downloaded or transferred to the Kivra mailbox, using the contact information provided by the tenant.

    ## Signature flow

    1. The tenant posts an agreement providing the PDF document to be signed and the list of parties, and gets back an `agreement id`. Parties are specified by their role, a SSN number and an email. The agreement is made available by Kivra to the parties.
    2. The tenant uses the document ID to check the agreement status. The agreement can also be revoked by the tenant, as long as it has not reached the `completed` state.
    3. Once the document has become `completed`, the tenant can download the `covenant file` via the API and save it, while parties have different options based on whether they are users of Kivra or not: for Kivra user the covenant file will be automatically transferred to the Kivra mailbox; for non Kivra user, parties have `30` days to either become a Kivra user and get the covenant file in the Kivra mailbox, or download the covenant file from the signature service for personal storage.
    4. The agreement is removed from all our services `30` days after creation in case the agreement does not reach the completed state. The agreement and covenant file are removed from all our services `30` days after the agreement reached the completed state. Once the agreement and covenant file have been removed, there will be no option for recovering them, only the verification option will be available. So it is important that both tenant and signers make sure that they have saved and safely stored the covenant file.

    ![Agreement Typical Flow](https://www.lucidchart.com/publicSegments/view/30bd1625-75d2-4ece-bb1d-5e3ccee93010/image.png)

    # Partners integration

    Partners integration allows a *company recipient* to open up its mailbox to a third party (a *partner*) to allow it to access and process the mailbox content. This is typically used by companies to allow bookkeeping and administrative third parties to access and process invoices and documents.

    Company recipients need to explicitly authorize a partner to access their content via a setting in their Kivra Company mailbox, and they can revoke access at any time. Both granting and revoking of access are performed via the Kivra app.

    Partners will use the `partner` endpoint to integrate with Kivra.

    # Errors

    Kivra uses conventional HTTP response codes to indicate the success or failure of an API request.

    In general:

    * Codes in the `2xx` range indicate success.
    * Codes in the `4xx` range indicate an error that failed given the information provided (e.g., a required parameter was omitted, invalid data, etc.).
    * Codes in the `5xx` range indicate an error with Kivra's servers or a timeout. In this case it is safe to retry the request.

    ## Error handling

    The integrator needs proper handling of common errors. Errors can happen at any stage and Kivra will report back to let the integrator take appropriate action.

    ### Recipient-file matching:

    Common errors that can occur and need to be handled gracefully.

    * Network problem that hinders the integrator from communicating with Kivra
    * Problem on Kivra’s end that hinders the integrator from querying the state of **Recipients**

    These errors should be handled gracefully such that the last working download of a **Recipient**-file is used until the problem has been solved and a new **Recipient**-file can be downloaded and used.

    ### Content Delivery:

    Common errors that can occur and need to be handled gracefully.

    * Network problem that hinders the integrator from communicating with Kivra resulting in either not being able to reach Kivra or a non-successful response-code
    * Problem with the **input**-file either due to above(network problem) or other such as corrupt data or invalid metadata.

    ## Error Messages

    When the KIVRA API returns error messages, it does so in a extended JSON format.

    > ### Example error response

    ```bash
    { "code"          : 40400
    , "short_message" : "Resource not found"
    , "long_message"  : "There's no resource at the given URI."
    }
    ```

    ### An error has three properties:

    | Property      | Description                                                |
    | ------------- | ---------------------------------------------------------- |
    | code          | The Kivra [error code](#error-codes)                       |
    | short_message | A short description of the error                           |
    | long_message  | A longer and more verbose error message                    |

    ## Extended error code

    The 5-digits extended error code is provided both in the body of the response and in the `x-error-code` filed of the response header.

    ## Error codes

    In addition to descriptive error text, error messages contain machine-parseable codes.
    While the text for an error message may change, the codes will stay the same.
    The following table describes the codes which may appear when working with the API:

    | Code | Short Message | Long Message |
    | ---- | ------------- | ------------ |
    |40000 |Request validation failed |The request payload does not pass required validation |
    |40001 |Invalid Request |The request was invalid |
    |40002 |Redirect URI Mismatch |The redirect_uri does not match the registered redirect_uri |
    |40003 |Invalid Scope | An invalid or insufficient scope was used |
    |40004 |Already registered |This user is already registered |
    |40005 |Error in phonenumber |The request can't be processed due to phonenumber not meeting the required format |
    |40006 |Error in password |The request can't be processed due to password not meeting the required format |
    |40007 |Error in email |The request can't be processed due to email not meeting the required format |
    |40008 |Unprocessable Entity |The JSON payload was malformed. The client should not resend the same payload without first correcting the erroneous JSON payload. |
    |40009 |Error in SSN |The request can't be processed due to SSN not meeting the required format. |
    |40010 |No action supplied or invalid |The action parameter was not supplied or invalid. |
    |40011 |Failed Extended Validation |The request can't be processed due to SSN and/or mobile failed extended validation. |
    |40012 |Error in type |The request can't be processed due to type field failing extended validation. |
    |40013 |Sendrequest already accepted |The request can't be processed due to user have already an accepted sendrequest |
    |40014 |Invalid Status |The request can't be processed due to invalid Status  |
    |40015 |Invalid Token |Invalid access_token provided |
    |40016 |Invalid State |The request can't be processed due to invalid State |
    |40017 |Invalid Campaigns |The request can't be processed due to invalid campaigns |
    |40018 |Error in Company ID |The request can't be processed due to Company ID not meeting the required format |
    |40019 |Invalid Files |The request can't be processed due to invalid files |
    |40020 |Invalid Parties |The request can't be processed due to invalid data for parties |
    |40021 |Invalid Bank Account |The request can't be processed due to invalid bank account |
    |40022 |Missing Postal Address |The request can't be processed due to missing postal address |
    |40023 |Invalid Contact Info |Invalid contact_info provided |
    |40024 |No Receiver Specified |Neither 'ssn' nor 'vat_number' has been specified as receiver |
    |40025 |Invalid OTP |The provided OTP is invalid or expired |
    |40026 |JSON payload was not an object |The JSON payload was malformed. Only JSON objects are supported |
    |40027 |Signature verification failed |Signup signature is invalid or signup data is altered |
    |40028 |UnsupportedFileType | The request can't be processed due to a data file was provided using an unsupported type |
    |40030 |IconSizeError | The request can't be processed due to the icon format not being compliant with the requirements |
    |40031 |PNG Missing Alpha Channel | Only PNG with alpha channel (PNG32) is allowed |
    |40032 |User doesn't exist | No user exists with provided SSN |
    |40033 |Invalid query parameters | One or more query parameters were invalid, e.g. bad format, not supported |
    |40035 |Required header missing | One or more required headers were missing in the request |
    |40036 |Resource Already Exists | The resource you are trying to create already exists |
    |40037 |Agreement parties are not unique | All agreement parties must have a unique SSN |
    |40038 |The provided destination URL does not meet our requirements | Its either not following the format https://subdomain.domain.tld/* or is not yet whitelisted in our system. Please contact us for support |
    |40039 |Cannot publish or update a canceled campaign | Cannot publish or update a canceled campaign |
    |40040 |Campaign must have an image | Cannot publish campaign without an image |
    |40041 |Invalid pay date | Pay date is in the past, too far in the future or not a bank day |
    |40042 |Invalid amount | The amount is out of range |
    |40043 |Invalid user preference | This preference is not supported |
    |40044 |Invalid OCR | The OCR did not pass validation |
    |40045 |Invalid option id | The option does not exist |
    |40047 |Invalid PDF |The supplied agreement PDF was invalid. Please check that the file is a valid PDF |
    |40050 |Form Response Error | Error processing form response |
    |40098 |Invalid barcode data | The barcode could not be created due to invalid barcode type |
    |40100 |Unauthorized |Supplied credentials was invalid |
    |40101 |Access Denied |The resource owner or authorization server denied the request |
    |40102 |Unauthorized Client |The client is not authorized to request an authorization code using this method. |
    |40103 |Invalid Grant |The provided authorization grant (e.g. authorization code, resource owner credentials) or refresh token is invalid, expired, revoked, does not match the redirection URI used in the authorization request, or was issued to another client. |
    |40104 |Invalid Client |Client authentication failed (e.g. unknown client, no client authentication included, or unsupported authentication method). |
    |40105 |Invalid Sendrequest |No sendrequest exists between sender and receiver, or sendrequest is not accepted. |
    |40106 |Email in use |This email adress is already in use and can not be used. |
    |40107 |Phone number is already in use |This phone number is already in use and can not be used. |
    |40108 |Registration Code or Sendrequest Invalid |The Registration Code is invalid or no Sendrequest exists or has been expired. |
    |40109 |Sendrequest or Share already exists or is blocked |An already existing Sendrequest exists or is blocked. |
    |40110 |Missing Print Integration |No print integration exists for the tenant |
    |40111 |Access Denied: Invalid OTP |The provided OTP is invalid or expired |
    |40112 |Access Denied: Insufficient Security Score |The requested resource requires a greater security score than the one associated with the current login method |
    |40113 |User does not exist with provided id |Contact us to enroll, make sure to include your id |
    |40300 |Forbidden |Access was denied to the given resource, authenticating will make no difference |
    |40400 |Not found |The resource was not found at the given URI at this time |
    |40500 |Method Not Allowed |The method specified in is not allowed for the resource at the requested URI |
    |40601 |Invalid Accept Header |The Accept Header contains a non valid or unknown Content-Type |
    |40915 |Conflict |An attempt was made to create an object that already exists |
    |41300 |Request Entity Too Large, the sent payload exceeded the maximum size limit |
    |42900 |Too Many Requests |Too many requests within this timespan have been made. Please try again later |

    # API - Authentication
    Kivra supports Oauth2 with Client Credentials flow. Each client has a `client_id` and a `client_secret` and these need to be base64 encoded and sent to the API via POST to receive an access token which is used for subsequent calls.

    Create the RFC 2045 base64 encoding to be used for tenant registration, replace `client_id` and `client_secret` with real values and make sure there are no trailing newlines (echo -n) and that the string is encoded literally (use single quotes and no escaping)

    ```bash
    $ echo -n 'client_id:client_secret' | base64
    Y2xpZW50X2lkOmNsaWVudF9zZWNyZXQ=
    ```

    Then perform the authentication which will respond with an access token.

    ### REQUEST: Authentication

    ```bash
    curl -i -X POST https://sender.api.kivra.com/v1/auth \
     -d "grant_type=client_credentials" \
     -H "Authorization: Basic Y2xpZW50X2lkOmNsaWVudF9zZWNyZXQ="
    ```

    ### RESPONSE: Authentication

    ```bash
    HTTP/1.1 200 OK
    Server: nginx
    Date: Thu, 02 Oct 2014 12:43:25 GMT
    Content-Type: application/json
    Content-Length: 124
    Connection: keep-alive
    Vary: Accept-Encoding
    Strict-Transport-Security: max-age=31536000;

    {
    "state":"",
    "access_token":"H6Zq08rF5fjQttd6fTKepWb3FQNptcip",
    "expires_in":28800,
    "scope":"kivra.v1.tenant.{tenant-key}.*",
    "token_type":"bearer"
    }
    ```

    <aside class="notice">
    An access_token is valid for eight(8) hours.
    </aside>

    A new `access_token` can be requested any time. If a request to the API is issued with a non valid `access_token` a http-response with the HTTP-header 401 is returned such as `HTTP/1.1 401 Unauthorized`. With the use of a `valid access_token` request to the API can be done as the example below.

    <aside class="warning">
    Note: Client Credentials and Access Tokens needs to be treated securely, It is how you securely identify your application's rights and identity when accessing the Kivra API. Do not distribute Client Credentials or Access Tokens in email, distributed native applications, client-side javascript, or public code repositories.
    </aside>

    ### Example request with access_token

    ```bash
    curl -i -X GET -H "Authorization: Bearer <access_token>" <api-url-to-object>
    ```
    ## Authorization with limited access scope

    In some particular configuration, for instance when a centralized service wants to provide a satellite service with possibility to only send content to Kivra for a specific tenant, but not allowing any other operation, the centralized service may request an access token for a specific tenant with a limited scope. This access token can be safely provided to the satellite service.

    To retrieve this access token, the client performs a new authorization with some extra parameters specifying the limited scope.

    ```shell
    curl -X POST \
    https://sender.api.kivra.com/v1/auth \
    -d grant_type=client_credentials \
    -d scope=post:kivra.v1.tenant.{tenant-key}.content \
    -H "Authorization: Basic {base64-auth}"
    ```

    The answer will look like the following:

    ```json
    {
      "state": "",
      "access_token": "DMWmtGWe9YpXep6FTgVEwWttxLR6D53z",
      "expires_in": 28800,
      "scope": "post:kivra.v1.tenant.{tenant-key}.content",
      "token_type": "bearer"
    }
    ```
    ### Scope
    Scopes are specified as one or a commaseparated list of methods with a path appended and separated by `:`.

    Method is a lower case string of one or more of the allowed methods, valid examples:

    | Example        | Details                                                    |
    | -----------    | ---------------------------------------------------------- |
    | `post:path`    | Allows `POST` for the given path                           |
    | `get,put:path` | Allows `GET` and `PUT` for the given path                  |

    Path is a lower case string starting with the keyword `kivra` and the path appended and interspersed with `.` instead
    of the path-separator `/` such as: `kivra.v1.example`. There is also the possibility to use wildcards:

    | Wildcard       | Details                                                        |
    | -----------    | -------------------------------------------------------------- |
    | `*`            | Marks a scope as valid for *any* keyword on **current-level**  |
    | `**`           | Marks a scope as valid for *any* keyword on **current-level** and **recursively**                 |

    <SecurityDefinitions/>

    # Payments: Swish support #

    This section describes functionality to be released in Q2 2023.

    A sender can designate Kivra as a Swish Technical Provider for them.

    A sender can then provide Kivra with one or more payee aliases.

    One payee alias _may_ be designated as the _default payee alias_.

    In an invoice sent to Kivra, the sender may include an optional field
    `swish_alias` in the payment data (see below for details). The content of
    this field, if it is included, must be one the sender's previously
    registered payee aliases or the string `disable` (see below). If it contains
    anything else, the field will be ignored.

    If an invoice has a valid `swish_alias`, the recipient will be offered to
    pay the invoice with Swish, and if they do so the given alias will be used
    as the payment destination.

    If an invoice does _not_ have a valid `swish_alias`, but the sender has
    designated one of their payee aliases as their _default payee alias_, the
    recipient of the content will be offered to pay the invoice with Swish,
    using the default payee alias as the payment destination.

    If a sender has designated a _default payee alias_, but want to indicate
    that a specific invoice should not be paid with Swish, they can do so by
    including the `swish_alias` field with the special value `disable`.

tags:
  - name: "Tenant API - Content"
    description: Endpoints for matching users and sending content
  - name: "Tenant API - Forms"
    description: |
      Endpoints for working with form templates and responses
  - name: "Tenant API - Tenant Management"
    description: Endpoints for creation and administration of tenants (v2)
  - name: "Tenant API - Agreements"
    description: Endpoints for managing signatures and agreements
  - name: "Partner API"
    description: Endpoints for partner access to company mailboxes

x-tagGroups:
  - name: Tenant API
    tags:
      - "Tenant API - Content"
      - "Tenant API - Forms"
      - "Tenant API - Tenant Management"
      - "Tenant API - Agreements"
  - name: Partner API
    tags:
      - "Partner API v1"
      - "Partner API v3"

paths:
  /vX/hamburger:
    get:
      summary: Get your burger
      operationId: Get your burger
      description: Get your free hamburger
      security:
        - oAuth2Client:
            - "get:kivra.vX.hamburger"
      responses:
        200:
          description: empty response confirming that the put operation was successful
          content:
            application/json:
              schema:
                type: object
                properties:
                  variant:
                    type: string
                    example: "Royale with Cheese"

  # ##############################################
  # POST, GET /v2/tenant
  # ##############################################
  /v2/tenant:
    post:
      tags:
        - "Tenant API - Tenant Management"
      summary: Create Tenant
      operationId: Create Tenant (v2)
      description: |
        Creation of tenants via API allows clients to create new tenants in an efficient manner. The created tenant is automatically added to the client scope. The client needs to re-authenticate to have the new scope in effect.
        <aside class="notice">
        Note: Creation of tenants via API is only allowed in certain specific cases and its usage needs to be regulated in the business relationship between the sender party and Kivra.
        </aside>
      security:
        - oAuth2Client:
            - "post:kivra.v2.tenant"
      responses:
        200:
          description: |
            Tenant already existing and added to the client scope
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Tenant_v2"
          headers:
            kivra-objkey:
              description: Tenant Key
              schema:
                type: string
                format: "hexadecimal value"
            location:
              description: URL to created Object
              schema:
                type: string
                format: url
        201:
          description: |
            Tenant Created succesfully
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Tenant_v2"
          headers:
            kivra-objkey:
              description: Tenant Key
              schema:
                type: string
                format: "hexadecimal value"
            location:
              description: URL to created Object
              schema:
                type: string
                format: url
        409:
          description: |
            The tenant could not be created because of a conflict, meaning that a tenant with the same `orgnr` already exists and cannot be automatically added to the client scope. The client may use the `request_access` endpoint to request access to this tenant.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error40915"
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Tenant_v2"
    get:
      tags:
        - "Tenant API - Tenant Management"
      summary: List tenants
      operationId: List all tenants accessible to the client
      description: Lists all tenants that are manageable by the current client
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant"
      parameters:
        - name: orgnr
          in: query
          description: Perform a search to see if a specific Company is available
          required: false
          schema:
            description: Companies unique Vat Number
            type: string
            example: SE556840226601
      responses:
        200:
          description: |
            List of available users
          content:
            application/json:
              schema:
                type: array
                description: List of tenants, can be empty
                items:
                  type: object
                  properties:
                    key:
                      type: string
                      description: Tenant ID
                  example:
                    [
                      { "key": "155748793356fa20e402ae472e51019cf723d7fe35" },
                      { "key": "150231793356fa88a88eae472e51019cf723d7d13a" },
                    ]

  # ##############################################
  # GET /v2/tenant/TKEY
  # ##############################################
  /v2/tenant/{tenantKey}:
    get:
      tags:
        - "Tenant API - Tenant Management"
      summary: Tenant information
      operationId: Get information on tenant
      description: Get detailed information on a tenant
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}"
      responses:
        200:
          description: |
            Tenant information
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Tenant_v2"

  # ##############################################
  # PUT /v2/tenant/TKEY/name
  # ##############################################
  /v2/tenant/{tenantKey}/name:
    put:
      tags:
        - "Tenant API - Tenant Management"
      summary: Update tenant name
      operationId: Update tenant name
      description: Update display name for the tenant. The updated name will be visible to the end-users only after they have received a new content.
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      security:
        - oAuth2Client:
            - "put:kivra.v2.tenant.{tenantKey}.name"
      responses:
        200:
          description: empty response confirming that the put operation was successful
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                name:
                  type: string
                  example: "Lenas Konditori AB"

  # ##############################################
  # POST /v2/tenant/TKEY/company_id
  # ##############################################
  /v2/tenant/{tenantKey}/company_id:
    post:
      tags:
        - "Tenant API - Tenant Management"
      summary: Associate company ID to tenant
      operationId: Add company ID
      description: |
        Add a new company ID for a tenant. A tenant can be associated with one or more company ids (Vat number and company name)
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      security:
        - oAuth2Client:
            - "post:kivra.v2.tenant.{tenantKey}.company_id"
      responses:
        204:
          description: empty response confirming that the post operation was successful
        409:
          description: Another tenant with the same `orgnr` already exists.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error40915"
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                company_id:
                  $ref: "#/components/schemas/CompanyId"

  # ##############################################
  # DELETE /v2/tenant/TKEY/company_id/{orgnr}
  # ##############################################
  /v2/tenant/{tenantKey}/company_id/{orgNr}:
    delete:
      tags:
        - "Tenant API - Tenant Management"
      summary: Delete company ID from tenant
      operationId: Delete company ID
      description: |
        Delete a  company ID from a tenant. A tenant can be associated with one or more company ids (Vat number and company name)
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: orgNr
          in: path
          description: The VAT number of the company_id to be removed from the tenant, for instance `SE556840226601`
          required: true
          schema:
            type: string
            format: hexadecimal
      security:
        - oAuth2Client:
            - "delete:kivra.v2.tenant.{tenantKey}.company_id.{orgnr}"
      responses:
        204:
          description: empty response confirming that the put operation was successful

  # ##############################################
  # POST /v2/tenant/TKEY/icon
  # ##############################################
  /v2/tenant/{tenantKey}/icon:
    post:
      tags:
        - "Tenant API - Tenant Management"
      summary: Provide an icon for a tenant
      operationId: Provide icon
      description: |
        Add or update the tenant icon. If an icon already exists, it will be changed.

        To check the current icon associated to a tenant you can simply check the following address:

        * sandbox: https://sandbox-static.kivra.com/img/tenant/{tenantKey}/icon.png
        * production: https://static.kivra.com/img/tenant/{tenantKey}/icon.png

        The icon needs to be provided according to the following format:

        * Dimensions: squared icon with size between 256x256 px and 512x512 px
        * Alpha Channel: 32-bits
        * Format: PNG
        * File size: up to 1MB

        We recommend to leave a little white area around the logo, to provide the best experience for the users.
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      security:
        - oAuth2Client:
            - "post:kivra.v2.tenant.{tenantKey}.icon"
      responses:
        204:
          description: empty response confirming that the put operation was successful
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                file:
                  $ref: "#/components/schemas/Icon"
            example:
              {
                "file":
                  {
                    "name": "fancy icon",
                    "data": "REVBR ...... EJFRUY=",
                    "content_type": "image/png",
                  },
              }

  # ##############################################
  # POST /v2/tenant/request_access
  # ##############################################
  /v2/tenant/request_access:
    post:
      tags:
        - "Tenant API - Tenant Management"
      summary: Request access to a tenant
      operationId: Request access
      description: |
        Request access to an existing tenant that is outside the client scope. Typically this request follows an unsuccessful attempt to create a tenant that resulted in a conflict error (error 409).

        The meaning of the conflict error is that a tenant is already associated to a `company_id` including the same `orgnr` as in the tenant that the client attempted to post, and the tenant who owns the `orgnr` is outside the scope for the client.

        In Kivra it is allowed to have several different flows on the same tenant, as for instance one flow for invoices and one flow for payment slips. As this flows could be managed by different clients, we need a mechanism to allow sharing a tenant between clients.
        The `request_access` endpoint provide this functionality. As the request may be granted (or denied) asynchronously, after a successfull call to `request_access` the client will need to poll the request until it becomes `accepted` or `rejected`.

        As allowing access to a new tenant requires modification of the scope for the client, an authorization must be performed once the request has been accepted, to retrieve an access token with the new scope.

        If the client posts a new identical request (requesting the same `OrgNr` for the same client), the same object will be returned with an updated status.
      security:
        - oAuth2Client:
            - "post:kivra.v2.tenant.request_access"
      responses:
        201:
          description: Data about the requested tenant
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/RequestAccess"
          headers:
            kivra-objkey:
              description: Object Key for the Request (requestKey)
              schema:
                type: string
                format: "hexadecimal value"
            location:
              description: The complete API url for where to check the status of this request
              schema:
                type: string
                format: "hexadecimal value"
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                vat_number:
                  type: string
                  example: "SE556840226601"

  # ##############################################
  # GET /v2/tenant/request_access/{requestKey}
  # ##############################################
  /v2/tenant/request_access/{requestKey}:
    get:
      tags:
        - "Tenant API - Tenant Management"
      summary: Status of an access request
      operationId: Request access status
      description: |
        Gets the updated status for a request generate using the `request_access` endpoint.
      parameters:
        - name: requestKey
          in: path
          description: The unique Key for a request
          required: true
          schema:
            type: string
            format: hexadecimal
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.request_access.{requestKey}"
      responses:
        200:
          description: Data about the requested tenant
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/RequestAccess"
          headers:
            kivra-objkey:
              description: Object Key for the Request
              schema:
                type: string
                format: "hexadecimal value"

  # ##############################################
  # GET /v1/tenant/TKEY/user
  # ##############################################
  /v1/tenant/{tenantKey}/user:
    get:
      tags:
        - "Tenant API - Content"
      summary: List available recipient users for a tenant
      operationId: List Users
      description: |
        This resource is used to list all or search for users that are eligible
        for receiving Content from the specific Tenant. The response is a JSON
        list of Objects containing the User's key and SSN. The `diffId`
        contained in the response header can be used to fetch added/removed
        users in subsequent requests to the
        `/v1/tenant/{tenantKey}/user/diff/{diffId}` endpoint.

        If a search is done with a query string and the user doesn’t exist or
        has Opt-ed out from receiving Content from the Tenant, an empty list
        is returned.

        Access to this resource might be enabled or disabled via agreement. To
        match a given list of users, please use the `usermatch` resource.
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: ssn
          in: query
          description: Perform a search to see if specific Users are available
          required: false
          schema:
            description: List of user SSNs
            type: string
            example: "191212121212"
        - name: include
          in: query
          description: List of fields that are returned for each user object
          required: false
          schema:
            type: string
            enum: ["ssn"]
            example: "ssn"
      security:
        - oAuth2Client:
            - "get:kivra.v1.tenant.{tenantKey}.user"
      responses:
        200:
          description: |
            List of available users
          headers:
            diff-id:
              description: |
                An ID that can be used in a subsequent request to
                `/v1/tenant/{tenantKey}/user/diff/{diffId}` to fetch users
                that were added/removed since `diffId` was obtained
              schema:
                type: string
                example: "3831CD15163421134211695294"
          content:
            application/json:
              schema:
                type: array
                description: List of available users, can be empty
                items:
                  $ref: "#/components/schemas/UserList"

  # ##############################################
  # GET /v1/tenant/TKEY/user/diff/{diffId}
  # ##############################################
  /v1/tenant/{tenantKey}/user/diff/{diffId}:
    get:
      tags:
        - "Tenant API - Content"
      summary: |
        List recipient users that were added/removed since a previous request
      operationId: List Users Diff
      description: |
        This resource is used to list users that were added/removed since
        `diffId` was obtained, either from an initial request to the
        `/v1/tenant/{tenantKey}/user` endpoint, or from a subsequent request
        to this endpoint. Note that all `diffId`s that are obtained in a
        series of requests expire 31 days after the **initial** request.
        Therefore, API users must fetch the complete user set at least once
        every 31 days.
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: diffId
          in: path
          description: |
            ID that was returned in header in a previous request and is used
            to calculate what users have been added/removed between that
            request and now
          required: true
          schema:
            type: string
            example: "3831CD15163421134211695294"
        - name: ssn
          in: query
          description: Perform a search to see if specific Users are available
          required: false
          schema:
            type: string
            example: "191212121212"
        - name: include
          in: query
          description: List of fields that are returned for each user object
          required: false
          schema:
            type: string
            enum: ["ssn"]
            example: "ssn"
      security:
        - oAuth2Client:
            - "get:kivra.v1.tenant.{tenantKey}.user.diff.{diffId}"
      responses:
        200:
          description: |
            Lists of added/removed users
          headers:
            diff-id:
              description: |
                An ID that can be used in a subsequent request to
                `/v1/tenant/{tenantKey}/user/diff/{diffId}` to fetch users
                that were added/removed since `diffId` was obtained
              schema:
                type: string
                example: "3831CD15163421134211695294"
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserDiff"
        404:
          description: |
            This error could indicate that the diffId is no longer valid
            and therefore the URL points to a resource that is no longer
            available

  # ##############################################
  # POST /v1/tenant/TKEY/usermatch
  # ##############################################
  /v1/tenant/{tenantKey}/usermatch:
    post:
      tags:
        - "Tenant API - Content"
      summary: Match a list of recipient users for a specific tenant
      operationId: Match Users
      description: |
        This resource is used to match a list of users to check that they are eligible for receiving Content from
          the specific Tenant.
        The request contains a list of SSNs to be matched, and the response is a filtered list containing only the SSNs that are eligible to receive content from the tenant.
        <aside class="notice">
          If none of the provided SSNs are eligible to receive content from this tenant, an empty list will be returned.
        </aside>
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      requestBody:
        description: |
          List of SSNs to be matched. The payload can be up to 10MB in size, corresponding to about 500.000 SSNs.
          If the payload exceeds 10MB, Kivra will respond with a 413 error.
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/UserMatch"
            example:
              ssns: ["191212121212", "197701032380", "198112172385"]
        required: true
      security:
        - oAuth2Client:
            - "get:kivra.v1.tenant.{tenantKey}.usermatch"
      responses:
        200:
          description: Filtered list of SSNs
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserMatch"
              example:
                ssns: ["191212121212", "198112172385"]

  # ##############################################
  # POST v2 usermatching
  # ##############################################
  /v2/tenant/{tenantKey}/usermatch/ssn:
    post:
      tags:
        - "Tenant API - Content"
      summary: Match a list of ssns to recipient for a specific tenant (v2)
      operationId: Match Users ssn v2
      description: |
        This resource is used to match a list of users to check that they are eligible for receiving Content from the specific Tenant.
        The request contains a list of recipient SSNs to be matched, and the response is a filtered list containing only the SSNs
        that are eligible to receive content from the tenant.
        <aside class="notice">
          If none of the provided SSNs are eligible to receive content from this tenant, an empty list will be returned.
        </aside>
      parameters:
        - name: tenantKey
          in: path
          description: The tenant key the matching should be done against. Recipients that opt-out from the tenant will be excluded.
          required: true
          schema:
            type: string
            format: hexadecimal
      requestBody:
        description: |
          List of SSNs to be matched. The payload can be up to 10MB in size, corresponding to about 500.000 SSNs.
          If the payload exceeds 10MB, Kivra will respond with a 413 error.
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/UserMatchV2SSN"
            example:
              list: ["191212121212","197701032380","198112172385"]
        required: true
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}.usermatch.ssn"
      responses:
        200:
          description: Filtered list of SSNs that matched.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserMatchV2SSN"
              example:
                list: ["191212121212", "198112172385"]

  /v2/tenant/{tenantKey}/usermatch/verified_email:
    post:
      tags:
        - "Tenant API - Content"
      summary: Match a list of emails to recipients for a specific tenant (v2)
      operationId: Match Users verified_email v2
      description: |
        This resource is used to match a list of users to check that they are eligible for receiving Content from the specific Tenant.
        The request contains a list of recipient email addresses to be matched, and the response is a filtered list containing only the
        email addresses that are eligible to receive content from the tenant.
        Email matching is case insensitive, but the queried email case is returned as submitted.
        <aside class="notice">
          If none of the provided email addresses are eligible to receive content from this tenant, an empty list will be returned.
        </aside>
      parameters:
        - name: tenantKey
          in: path
          description: The tenant key the matching should be done against. Recipients that opt-out from the tenant will be excluded.
          required: true
          schema:
            type: string
            format: hexadecimal
      requestBody:
        description: |
          List of email addresses to be matched. The payload can be up to 10MB in size.
          If the payload exceeds 10MB, Kivra will respond with a 413 error.
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/UserMatchV2Email"
            example:
              list: ["fOO@example.com","bAr@EXAMPLE.COM","XYZ@example.COM"]
        required: true
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}.usermatch.verified_email"
      responses:
        200:
          description: Filtered list of email addresses that matched.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/UserMatchV2Email"
              example:
                list: ["fOO@example.COM", "bAr@EXAMPLE.COM"]

  # ##############################################
  # GET /v1/tenant/TKEY/company
  # ##############################################
  /v1/tenant/{tenantKey}/company:
    get:
      tags:
        - "Tenant API - Content"
      summary: List available recipient companies for a tenant
      operationId: List Companies
      description: |
        This resource is used to list all or search for companies that eligible for receiving Content from the specific Tenant.
        The response is a JSON list of Objects containing the Companies key and Vat Number.

        <aside class="notice">
        If a search is done and the Company doesn’t exist or have Opt-ed out of receiving Content from the Tenant an empty list will be returned.
        </aside>
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: vat_number
          in: query
          description: Perform a search to see if a specific Company is available
          required: false
          schema:
            description: Companies unique Vat Number
            type: string
            example: SE556840226601
      security:
        - oAuth2Client:
            - "get:kivra.v1.tenant.{tenantKey}.company"
      responses:
        200:
          description: |
            List of available companies
          content:
            application/json:
              schema:
                type: array
                description: List of available companies, can be empty
                items:
                  $ref: "#/components/schemas/CompanyList"

  # ##############################################
  # POST /v1/tenant/TKEY/content
  # ##############################################
  /v1/tenant/{tenantKey}/content:
    post:
      tags:
        - "Tenant API - Content"
      summary: Send content (v1)
      operationId: Send content
      description: |
        Metadata is data that Kivra needs to send the Content to the right User. It may also determine how a User can interact with the Content.

        ### Minimum Metadata
        As a minimum one valid recipient identifier is required (`vat_number`, `ssn` or `email`).

        In case several identifiers are specified, Kivra will only try to match the first one and not fall through to try to match the remaining identifiers.
        More specifically Kivra will look first for a `vat_number`, if this is not provided it will look for a `ssn`, if this is not provided either it will look for `email`.

        E.g. if a content has both an `ssn` and `email`, only the `ssn` will be used as identifier, even if there is no positive `ssn` match.
        </aside>

        ### Content v1 vs v2
        There are two API resources to send content to a recipient:
          - `/v1/tenant/TKEY/content` can be used to send one or more PDFs to a recipient.
          - `/v2/tenant/TKEY/content` (documented below) can be used to send PDFs (same as `v1`) or sending one or more HTML+PDF pairs (referred to as responsive content) to a recipient.
          To learn more about the advantages of responsive content see the relative section below in this documentation.

        ### Retained Content
        A retained Content is a Content that is sent to a Recipient who is not yet a user of Kivra. Once that Recipient register with Kivra, the Content will be delivered to that Recipient’s Kivra account. Retained Content has a time limit for how long they can be retained before being deleted, ie removed unless the Recipient registers within a given period of time.

        <aside class="notice">
        Note: Usage of retained content is only allowed for documents of type credit notice and salary slip.
        </aside>

        Sending retained Content uses all the same attributes as a normal Content with the difference for some additional metadata-attributes.
        By enabling the `retain` metadata attribute and setting it to `true` will enable possible retention of a Content. Kivra’s logic is to first look if the Recipient exist. If it does Kivra will deliver the Content as usual, if the Recipient doesn’t exist Kivra will retain the Content for the default amount of time (*30 days*). This makes it easy for an Integrator to issue a "retain or deliver"-logic for all it’s Contents.

        If an integrator want to retain a Content for a another time-period than Kivra’s default if can be done via the `retention_time` additional metadata.

        ### Duplicate control
        If exactly the same payload (content plus metadata, with only exception being the `generated_at` field) is received more than once, only the first occurrence will result in a delivery. In the other occurrences an OK message will be returned, but no corresponding content will be delivered to the receiver. This is a security mechanism to allow senders to safely re-send the same payload in case there is uncertainty on whether the previous sending resulted in a delivery or not. A typical example is in case of timeout error, where the sender cannot establish whether the sending resulted in a content delivery or not.

        <aside class="notice">
        Note: Duplicate control is only available in production, not in sandbox. This allows senders to reuse the same payload several times in the test environment.
        </aside>

        It's important to underline that the duplicate control is made by checking the complete payload (beside `generated_at`), not only the attached content. This means that any change in the payload will cause the duplicate check to fail and the corresponding content to be delivered.

        Another important consequence is that in case a sender wants to safely re-send a PDF content, it is important that the PDF is not generated again between the API calls as this almost certainly results in a slightly different PDF and therefore in a different payload, meaning that the duplication check will not be able to recognise it as a duplicate.

      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.content"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        201:
          description: |
            Content Created succesfully
          content:
            application/json:
              schema:
                oneOf:
                  - $ref: "#/components/schemas/Content_user"
                  - $ref: "#/components/schemas/Content_company"
          headers:
            kivra-objkey:
              description: Object Key
              schema:
                type: string
                format: "hexadecimal value"
            kivra-retained:
              description: |
                Boolean denoting if a Content was Retained, Note: this header is **only** returned when a Content is retained
              schema:
                type: boolean
            location:
              description: URL to created Object
              schema:
                type: string
                format: url
      requestBody:
        content:
          application/json:
            schema:
              oneOf:
                - $ref: "#/components/schemas/Content_user"
                - $ref: "#/components/schemas/Content_company"
            examples:
              invoice to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment:
                        payable: true
                        currency: SEK
                        due_date: "2017-01-01"
                        total_owed: "123.50"
                        type: SE_OCR
                        method: "1"
                        account: "12345"
                        reference: 426523791
                      invoice_reference: "Invoice Nr #123"
              invoice with variable amount to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment:
                        payable: true
                        currency: SEK
                        due_date: "2017-01-01"
                        total_owed: "123.50"
                        type: SE_OCR
                        method: "1"
                        account: "12345"
                        reference: 426523791
                        variable_amount: true
                        min_amount: "50.00"
                      invoice_reference: "Invoice Nr #123"
              invoice with multiple payment options to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment_multiple_options:
                        payable: true
                        currency: SEK
                        account: "123456"
                        method: "1"
                        options:
                          - due_date: "2024-02-29"
                            amount: "4711.23"
                            type: "SE_OCR"
                            reference: "771554193"
                            title: "Option 1"
                            description: "The first options in this invoice."
                            icon:
                              name: "this_will_be_ignored.png"
                              content_type: "image/png"
                              data: "Base64-encoded string with PNG data"
                          - due_date: "2024-03-31"
                            amount: "11147.42"
                            type: "SE_OCR"
                            reference: "771554194"
                            title: "Option 2"
                            description: "The second options in this invoice."
                            icon:
                              name: "this_will_be_ignored.png"
                              content_type: "image/png"
                              data: "A different base64-encoded string with PNG data"
                      invoice_reference: "Invoice #24"
              content with flexible option:
                value:
                  ssn: "191212121212"
                  subject: Flexible Invoice to User
                  generated_at: "2022-12-12"
                  type: "invoice"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment_multiple_options:
                        payable: true
                        currency: SEK
                        account: "123456"
                        method: "1"
                        options:
                          - due_date: "2024-02-29"
                            amount: "4711.23"
                            type: "SE_OCR"
                            reference: "771554193"
                            title: "Option 1"
                            description: "The first options in this invoice."
                            icon:
                              name: "this_will_be_ignored.png"
                              content_type: "image/png"
                              data: "Base64-encoded string with PNG data"
                        flexible_option:
                          due_date: "2024-02-29"
                          type: "SE_OCR"
                          reference: "771554195"
                          title: "Flexible Option"
                          description: "A flexible option."
                          icon:
                            name: "this_will_be_ignored.png"
                            content_type: "image/png"
                            data: "Base64-encoded string with PNG data"
                            min_limit: "17.00"
                            min_suggested: "23.50"
                            max_suggested: "235.00"
                            max_limit: "500"
                      invoice_reference: "Invoice #23"
              letter to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Letter to User
                  generated_at: "2016-12-12"
                  type: "letter"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
              payslip to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Payslip to User
                  generated_at: "2016-12-12"
                  type: "letter.salary"
                  retain: true
                  retention_time: "390"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
              creditnotice to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Creditnotice to User
                  generated_at: "2020-12-12"
                  type: "letter.creditnotice"
                  retain: true
                  retention_time: "30"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
              booking to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Booking to User
                  generated_at: "2016-12-12"
                  type: "booking"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    booking:
                      title: "Appointment"
                      start_time: "2026-12-12T10:00:00Z"
                      end_time: "2026-12-12T11:00:00Z"
                      location: "Somewhere"
                      description: "More details"
                      info_url: url
              invoice.debtcampaign to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Debtcampaign Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice.debtcampaign"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment:
                        payable: true
                        currency: SEK
                        due_date: "2017-01-01"
                        total_owed: "123.50"
                        type: SE_OCR
                        method: "1"
                        account: "12345"
                        reference: 426523791
                      invoice_reference: "Invoice Nr #123"
              invoice reminder to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice Reminder to User
                  generated_at: "2016-12-12"
                  type: "invoice.reminder"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment:
                        payable: true
                        currency: SEK
                        due_date: "2017-01-01"
                        total_owed: "123.50"
                        type: SE_OCR
                        method: "1"
                        account: "12345"
                        reference: 426523791
                      invoice_reference: "Invoice Nr #123"
              invoice renewal to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice Renewal to User
                  generated_at: "2016-12-12"
                  type: "invoice.renewal"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment:
                        payable: true
                        currency: SEK
                        due_date: "2017-01-01"
                        total_owed: "123.50"
                        type: SE_OCR
                        method: "1"
                        account: "12345"
                        reference: 426523791
                      invoice_reference: "Invoice Nr #123"
              content to company:
                value:
                  vat_number: SE556840226601
                  subject: Sample Content to Company
                  generated_at: "2016-12-12"
                  type: "letter"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf

  # ##############################################
  # POST /v2/tenant/TKEY/content
  # ##############################################
  /v2/tenant/{tenantKey}/content:
    post:
      tags:
        - "Tenant API - Content"
      summary: Send content (v2)
      operationId: Send responsive content
      description: |
        Metadata is data that Kivra needs to send the Content to the right User. It may also determine how a User can interact with the Content.

        ### Minimum Metadata
        As a minimum one valid recipient identifier is required (`vat_number`, `ssn` or `email`).

        In case several identifiers are specified, Kivra will only try to match the first one and not fall through to try to match the remaining identifiers.
        More specifically Kivra will look first for a `vat_number`, if this is not provided it will look for a `ssn`, if this is not provided either it will look for `email`.

        E.g. if a content has both an `ssn` and `email`, only the `ssn` will be used as identifier, even if there is no positive `ssn` match.
        </aside>

        ### Content v1 vs v2
        There are two API resources to send content to a recipient:
          - `/v1/tenant/TKEY/content` (documented above) can be used only to send one or more PDFs to a recipient.
          - `/v2/tenant/TKEY/content` can be used to send PDFs (same as `v1`) or sending one or more HTML+PDF pairs (referred to as responsive content) to a recipient.
          To learn more about the advantages of responsive content see the relative section below in this documentation.

        ### Benefits and usage of responsive content
        As more than 90% of the content sent in Kivra is consumed on mobile devices, it is important to be able to show to the recipient the most important information in an easyly readable way, without relying on the recipient to zoom in on the area of the PDF where the information is presented.

         Responsive content solve this problem by allowing senders to provide 2 versions of the content:
          - a PDF which contains all the information and details that needs to be presented to the recipient
          - an HTML version of the same content that includes an overview of the information and highlights what the sender wants to present to the user.

        Here are a couple of examples on how to use HTML resp. PDF in your communication:
        - Let's consider an invoice where the PDF contains all the information that the invoice must include, while the responsive part (HTML) contains only the due amount, the due date, some information about the product or service that was delivered, the benefits for the customer for using the supplier and some brand information.
        -  Let's consider a salary specification where the PDF contains all the details and how the salary was calculated while the HTML presentes only some key information like the salary total, when the money will be paid and the number of vacation days left.

        ### Restrictions for the HTML part
        Kivra is an archive and it is very important that content sent in Kivra is immutable and does not update itself over time. The recipient should be able to return to a received content at any point in time and see it exactly as it was when it was received.

        As HTML is a format that offers many possibilities there are restrictions on how the HTML is formed:
        - No javascript: **no javascript allowed**, neither inline or fetched from external resources
        - External documents such as images, icons, css, etc. **must be embedded inline in the HTML** file to avoid external links to become bad over time and break the rendering of the HTML

        Privacy is also an important concern for Kivra. For this reason common links are allowed in the HTML but **no user-specific tracking links are allowed**, for instance links containing UTMs or other technology to track the behavior of each particular user.

        ### Retained Content
        A retained Content is a Content that is sent to a Recipient who is not yet a user of Kivra. Once that Recipient register with Kivra, the Content will be delivered to that Recipient’s Kivra account. Retained Content has a time limit for how long they can be retained before being deleted, ie removed unless the Recipient registers within a given period of time.

        <aside class="notice">
        Note: Usage of retained content is only allowed for documents of type credit notice and salary slip.
        </aside>

        Sending retained Content uses all the same attributes as a normal Content with the difference for some additional metadata-attributes.
        By enabling the `retain` metadata attribute and setting it to `true` will enable possible retention of a Content. Kivra’s logic is to first look if the Recipient exist. If it does Kivra will deliver the Content as usual, if the Recipient doesn’t exist Kivra will retain the Content for the default amount of time (*30 days*). This makes it easy for an Integrator to issue a "retain or deliver"-logic for all it’s Contents.

        If an integrator want to retain a Content for a another time-period than Kivra’s default if can be done via the `retention_time` additional metadata.

        ### Duplicate control
        If exactly the same payload (content plus metadata, with only exception being the `generated_at` field) is received more than once, only the first occurrence will result in a delivery. In the other occurrences an OK message will be returned, but no corresponding content will be delivered to the receiver. This is a security mechanism to allow senders to safely re-send the same payload in case there is uncertainty on whether the previous sending resulted in a delivery or not. A typical example is in case of timeout error, where the sender cannot establish whether the sending resulted in a content delivery or not.

        <aside class="notice">
        Note: Duplicate control is only available in production, not in sandbox. This allows senders to reuse the same payload several times in the test environment.
        </aside>

        It's important to underline that the duplicate control is made by checking the complete payload (beside `generated_at`), not only the attached content. This means that any change in the payload will cause the duplicate check to fail and the corresponding content to be delivered.

        Another important consequence is that in case a sender wants to safely re-send a PDF content, it is important that the PDF is not generated again between the API calls as this almost certainly results in a slightly different PDF and therefore in a different payload, meaning that the duplication check will not be able to recognise it as a duplicate.

      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.content"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        201:
          description: |
            Content Created succesfully
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Content_user"
          headers:
            kivra-objkey:
              description: Object Key
              schema:
                type: string
                format: "hexadecimal value"
            kivra-retained:
              description: |
                Boolean denoting if a Content was Retained, Note: this header is **only** returned when a Content is retained
              schema:
                type: boolean
            location:
              description: URL to created Object
              schema:
                type: string
                format: url
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Content_user_v2"
            examples:
              invoice to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  payment:
                    payable: true
                    currency: SEK
                    due_date: "2017-01-01"
                    total_owed: "123.50"
                    type: SE_OCR
                    method: "1"
                    account: "12345"
                    reference: 426523791
              invoice with variable amount to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  payment:
                    payable: true
                    currency: SEK
                    due_date: "2017-01-01"
                    total_owed: "123.50"
                    type: SE_OCR
                    method: "1"
                    account: "12345"
                    reference: 426523791
                    variable_amount: true
                    min_amount: "50.00"
              invoice with multiple payment options to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  payment_multiple_options:
                    payable: true
                    currency: SEK
                    account: "123456"
                    method: "1"
                    options:
                      - due_date: "2024-02-29"
                        amount: "4711.23"
                        type: "SE_OCR"
                        reference: "771554193"
                        title: "Option 1"
                        description: "The first options in this invoice."
                        icon:
                          name: "this_will_be_ignored.png"
                          content_type: "image/png"
                          data: "Base64-encoded string with PNG data"
                      - due_date: "2024-03-31"
                        amount: "11147.42"
                        type: "SE_OCR"
                        reference: "771554194"
                        title: "Option 2"
                        description: "The second options in this invoice."
                        icon:
                          name: "this_will_be_ignored.png"
                          content_type: "image/png"
                          data: "A different base64-encoded string with PNG data"
              invoice with flexible option:
                value:
                  ssn: "191212121212"
                  subject: Flexible Invoice to User
                  generated_at: "2022-12-12"
                  type: "invoice"
                  files:
                    - name: filename.pdf
                      data: REVBREJFRUY=
                      content_type: application/pdf
                  context:
                    invoice:
                      payment_multiple_options:
                        payable: true
                        currency: SEK
                        account: "123456"
                        method: "1"
                        options:
                          - due_date: "2024-02-29"
                            amount: "4711.23"
                            type: "SE_OCR"
                            reference: "771554193"
                            title: "Option 1"
                            description: "The first options in this invoice."
                            icon:
                              name: "this_will_be_ignored.png"
                              content_type: "image/png"
                              data: "Base64-encoded string with PNG data"
                        flexible_option:
                          due_date: "2024-02-29"
                          type: "SE_OCR"
                          reference: "771554195"
                          title: "Flexible Option"
                          description: "A flexible option."
                          icon:
                            name: "this_will_be_ignored.png"
                            content_type: "image/png"
                            data: "Base64-encoded string with PNG data"
                            min_limit: "17.00"
                            min_suggested: "23.50"
                            max_suggested: "235.00"
                            max_limit: "500"
                      invoice_reference: "Invoice #23"
              letter to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Content to User
                  generated_at: "2016-12-12"
                  type: "letter"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
              letter to user (identified by email):
                value:
                  email: "someone@example.com"
                  subject: Sample Letter to User (identified by email)
                  generated_at: "2016-12-12"
                  type: "letter"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
              payslip to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Payslip to User
                  generated_at: "2016-12-12"
                  type: "letter.salary"
                  retain: true
                  retention_time: "390"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
              creditnotice to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Creditnotice to User
                  generated_at: "2020-12-12"
                  type: "letter.creditnotice"
                  retain: true
                  retention_time: "30"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
              booking to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Booking to User
                  generated_at: "2016-12-12"
                  type: "booking"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  booking:
                    title: "Appointment"
                    start_time: "2026-12-12T10:00:00Z"
                    end_time: "2026-12-12T11:00:00Z"
                    location: "Somewhere"
                    description: "More details"
                    info_url: url
              invoice.debtcampaign to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Debtcampaign Invoice to User
                  generated_at: "2016-12-12"
                  type: "invoice.debtcampaign"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  payment:
                    payable: true
                    currency: SEK
                    due_date: "2017-01-01"
                    total_owed: "123.50"
                    type: SE_OCR
                    method: "1"
                    account: "12345"
                    reference: 426523791
              invoice reminder to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice Reminder to User
                  generated_at: "2016-12-12"
                  type: "invoice.reminder"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  payment:
                    payable: true
                    currency: SEK
                    due_date: "2017-01-01"
                    total_owed: "123.50"
                    type: SE_OCR
                    method: "1"
                    account: "12345"
                    reference: 426523791
              invoice renewal to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Invoice Renewal to User
                  generated_at: "2016-12-12"
                  type: "invoice.renewal"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
                  payment:
                    payable: true
                    currency: SEK
                    due_date: "2017-01-01"
                    total_owed: "123.50"
                    type: SE_OCR
                    method: "1"
                    account: "12345"
                    reference: 426523791
              content to company:
                value:
                  vat_number: SE556840226601
                  subject: Sample Content to Company
                  generated_at: "2016-12-12"
                  type: "letter"
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
              form to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Content to User
                  generated_at: "2016-12-12"
                  type: "letter.form"
                  form:
                    id: 2877d684-a340-4e4c-867f-d93283787b01
                    sender_reference:
                      internal_id: 6eb7d1b9-ccd6-408f-ade7-9a1837be3ecf
                    days_to_expiry: 30
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html
              campaign to user:
                value:
                  ssn: "191212121212"
                  subject: Sample Content to User
                  generated_at: "2016-12-12"
                  type: "letter"
                  campaign:
                    tag: summer_2023
                  parts:
                    name: document.pdf
                    data: REVBREJFRUY=
                    content_type: application/pdf
                    responsive_part:
                      name: document.html
                      data: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
                      content_type: text/html

  # ##############################################
  # POST, GET /v1/tenant/tenantKey/form
  # ##############################################
  /v2/tenant/{tenantKey}/form:
    post:
      tags:
        - "Tenant API - Forms"
      summary: Create form template
      operationId: createFormTemplate
      description: |
        A form template is a list of questions you would like to ask users. When sending content you can attach a form you would like a user to complete.

        Form templates are owned by the client that created them. What this means is that only the client can call the response endpoints.
        However if the client has the tenant scope it can call form template endpoints and even include a form when sending content.

        ### How to send a form to the user
        When sending a content to the user include the form template key in the context object. See `Tenant API - Content` -> `Send content (PDF) to a recipient (user or company)` for more information.
      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The tenant key for the tenant who is creating the form template.
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        200:
          description: |
            Form template created
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/FormTemplate"
        400:
          description: |
            Can't process the request. Likely due to a client error.
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/FormErrorResponse"
              examples:
                invalid_json:
                  value:
                    code: 40000
                    short_message: "Invalid JSON"
                    long_message: "Could not parse posted body as JSON"
        401:
          description: |
            Not authorized to make the request.
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/FormTemplate"
    get:
      tags:
        - "Tenant API - Forms"
      summary: Get form template keys
      operationId: getFormTemplateKey
      description: |
        Given a tenant key returns all form template keys associated with forms they created.
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The unique key for a tenant for whom the form templates belongs to.
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        200:
          description: |
            List of form template keys
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/FormTemplateKey"
        401:
          description: |
            Not authorized to make the request

  # ##############################################
  # GET /v2/tenant/{tenantKey}/form/{formTemplateKey}
  # ##############################################
  /v2/tenant/{tenantKey}/form/{formTemplateKey}:
    get:
      tags:
        - "Tenant API - Forms"
      summary: Get form template
      operationId: getFormTemplate
      description: |
        Given a tenant key and a form template key returns the form template that the tenant created.
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The unique key for a tenant for whom the form template belongs to.
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: formTemplateKey
          in: path
          description: The form template key associated with the form template.
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          description: |
            Form template
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/FormTemplate"
        401:
          description: |
            Not authorized to make the request
        404:
          description: |
            Form template not found

  # ##############################################
  # GET /v2/tenant/{tenantKey}/form/{formTemplateKey}/responses
  # ##############################################
  /v2/tenant/{tenantKey}/form/{formTemplateKey}/responses:
    get:
      tags:
        - "Tenant API - Forms"
      summary: Get form response keys
      operationId: getFormResponseKeys
      description: |
        Only the client that created the form template associated with the response can call this endpoint.

        Given a tenant key and a form template key returns the form response key associated with form responses submitted by users.
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The unique key for a tenant for whom the form responses belong to.
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: formTemplateKey
          in: path
          description: The form template key associated with the form responses.
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          description: |
            Form response ids
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/FormResponseKeys"
        400:
          description: |
            Can't process the request. Likely due to a client error.
        401:
          description: |
            Not authorized to make the request
        403:
          description: |
            Forbidden from accessing the form response keys
        404:
          description: |
            The form template associated with formTemplateKey does not exist.


  # ##############################################
  # GET, DELETE /v2/tenant/{tenantKey}/form/{formTemplateKey}/responses/{responseKey}
  # ##############################################
  /v2/tenant/{tenantKey}/form/{formTemplateKey}/responses/{formResponseKey}:
    get:
      tags:
        - "Tenant API - Forms"
      summary: Get form response
      operationId: getFormResponse
      description: |
        Only the client that created the form template associated with the response can call this endpoint.

        Given a tenant key, form template key and form response key returns the form response submitted by a user.
      security:
        - oAuth2Client:
            - "get:kivra.v2.tenant.{tenantKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The unique key for a tenant for whom the form response belongs to.
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: formTemplateKey
          in: path
          description: The form template key associated with the form template.
          required: true
          schema:
            type: string
            format: uuid
        - name: formResponseKey
          in: path
          description: The form response key associated with the form response.
          required: true
          schema:
            type: string
            format: uuid
      responses:
        200:
          description: |
            Form response
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/FormResponse"
        400:
          description: |
            Can't process the request. Likely due to a client error.
        401:
          description: |
            Not authorized to make the request
        403:
          description: |
            Forbidden from accessing the form response keys
        404:
          description: |
            Either the form template associated with the given formTemplateKey does not exist or the form response associated with the given responseKey does not exist.
    delete:
      tags:
        - "Tenant API - Forms"
      summary: Delete form response
      operationId: deleteFormResponse
      description: |
        Given a tenant key, form template key and form response key deletes the form response submitted by a user.

        Only the client that created the form template associated with the response can call this endpoint.

        ### Form responses potentially contain sensitive data. You are recommended to delete form responses from Kivra as you consume them.
      security:
        - oAuth2Client:
            - "delete:kivra.v2.tenant.{tenantKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant for whom the form belongs to.
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: formTemplateKey
          in: path
          description: The form_template_key associated with the form template.
          required: true
          schema:
            type: string
            format: uuid
        - name: formResponseKey
          in: path
          description: The form response key associated with the form responses.
          required: true
          schema:
            type: string
            format: uuid
      responses:
        204:
          description: |
            Form deleted
        400:
          description: |
            Can't process the request. Likely due to a client error.
        401:
          description: |
            Not authorized to make the request
        403:
          description: |
            Forbidden from accessing the form response keys
        404:
          description: |
            Either the form template associated with the given formTemplateKey does not exist or the form response associated with the given responseKey does not exist.

  # ##############################################
  # GET,POST /v1/tenant/TKEY/agreement
  # ##############################################
  /v1/tenant/{tenantKey}/agreement:
    post:
      tags:
        - "Tenant API - Agreements"
      summary: Post an agreement to be signed
      operationId: Post Agreement
      description:
        This resource is used to post an agreement to be signed by the recipients
        listed in the metadata. An Agreement ID will be returned.
      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.agreement"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        200:
          description: Agreement created succesfully
          content:
            application/json:
              schema:
                type: string
                example: "15544700816b7d63c83d6e476493879b5043ec9d7b"
        400:
          description: Agreement PDF was invalid
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error40045"
      requestBody:
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Agreement"
    get:
      tags:
        - "Tenant API - Agreements"
      summary: List all agreements for a tenant, with their current status
      operationId: List agreements
      description: List all agreements created by a tenant, with their current status.
      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.agreement"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        "200":
          description: List of agreements and their status
          content:
            application/json:
              schema:
                type: array
                description: list
                items:
                  $ref: "#/components/schemas/AgreementStateShort"
                example:
                  - key: "1527232009ba54f8186d8c43e2a3c8092b57ca2739"
                    state: active
                  - key: "155265136911763308f2514ff3aa6dacc8211a2107"
                    state: revoked
                  - key: "15100645203cff9f19d92443848c8a2f1cbf257510"
                    state: completed

  # ##############################################
  # GET /v1/tenant/TKEY/agreement/AKEY
  # ##############################################
  /v1/tenant/{tenantKey}/agreement/{agreementKey}:
    get:
      tags:
        - "Tenant API - Agreements"
      summary: Agreement object with current status and updated metadata
      operationId: Get agreement
      description: Get an agreement with current status and updated metadata
      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.agreement.{agreementKey}"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: agreementKey
          in: path
          description: The unique Key for an Agreement
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        "200":
          description: Agreement object with current status and updated metadata
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/AgreementStateDetailed"

  # ##############################################
  # GET /v1/tenant/TKEY/agreement/AKEY/revoke
  # ##############################################
  /v1/tenant/{tenantKey}/agreement/{agreementKey}/revoke:
    post:
      tags:
        - "Tenant API - Agreements"
      summary: Revoke an agreement
      operationId: Revoke agreement
      description: |
        Revoke an agreement. An agreement once revoked can no longer be accessed or signed by any of the parties. An agreement can only be rekoved if in state *active*, and after revoke will be put in state *revoked*. A revoked agreement can never become active again.
      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.agreement.{agreementKey}.revoke"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: agreementKey
          in: path
          description: The unique Key for an Agreement
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        "204":
          description: empty response confirming that the revoke operation was successful
      requestBody:
        description: empty JSON body
        content:
          application/json:
            schema: {}

  # ##############################################
  # GET /v1/tenant/TKEY/agreement/AKEY/covenant
  # ##############################################
  /v1/tenant/{tenantKey}/agreement/{agreementKey}/covenant:
    get:
      tags:
        - "Tenant API - Agreements"
      summary: Get the covenant file (signed agreement)
      operationId: Get covenant agreement
      description: |
        Get the covenant file (the signed version of the agreement).
      security:
        - oAuth2Client:
            - "post:kivra.v1.tenant.{tenantKey}.agreement.{agreementKey}.covenant"
      parameters:
        - name: tenantKey
          in: path
          description: The unique Key for a Tenant
          required: true
          schema:
            type: string
            format: hexadecimal
        - name: agreementKey
          in: path
          description: The unique Key for an Agreement
          required: true
          schema:
            type: string
            format: hexadecimal
      responses:
        "200":
          description: The covenant file as a PDF file with base64 encoding
          content:
            application/json:
              schema:
                type: object
                properties:
                  name:
                    description: The name of the file
                    type: string
                    example: "agreement7456_completed.pdf"
                  data:
                    description: The covenant file as a PDF file with base64 encoding
                    type: string
                    format: base64
                    example: "REVBREJFRUY="
                  sha256:
                    description: the signature to verify the file's authenticity
                    type: string

  # ##############################################
  # GET /v1/partner/company
  # ##############################################
  /v1/partner/company:
    get:
      tags:
        - "Partner API v1"
      summary: Lookup a specific company
      operationId: Find Company
      description: |
        This resource allows a partner to look if a specific company has granted access to its mailbox.
        <aside class="notice">
        If a search is done and the Company doesn’t exist in Kivra or has not granted access to the partner, an empty list will be returned.
        </aside>
      parameters:
        - name: vat_number
          in: query
          description: Perform a search to see if a specific Company is available for access
          required: true
          schema:
            description: Company's unique VAT number
            type: string
            example: SE556840226601
      security:
        - oAuth2Client:
            - "get:kivra.v1.partner.company"
      responses:
        200:
          description: Company key for the company with the matching VAT number
          content:
            application/json:
              schema:
                type: object
                properties:
                  key:
                    description: Company's unique Key
                    type: string
                    example: "15236156848eefa1dc75364af2be38c98eb3aae223"

  # ##############################################
  # GET /v1/partner/company/COMPKEY/content
  # ##############################################
  /v1/partner/company/{companyKey}/content:
    get:
      tags:
        - "Partner API v1"
      summary: Get the company inbox
      operationId: Get company inbox
      description: This resource allows to access a high level description for each content in the company inbox, to allow for a first sorting and filtering of the content.
      parameters:
        - name: companyKey
          in: path
          description: The unique key for the company object being retrieved
          required: true
          schema:
            description: Company's unique key
            type: string
      security:
        - oAuth2Client:
            - "get:kivra.v1.partner.company.{companyKey}"
      responses:
        200:
          description: High level description of content items in the company inbox
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: "#/components/schemas/CompanyInbox"

  # ##############################################
  # GET /v1/partner/company/COMPKEY/content/CONTKEY
  # ##############################################
  /v1/partner/company/{companyKey}/content/{contentKey}:
    get:
      tags:
        - "Partner API v1"
      summary: Get metadata for a content.
      operationId: Get content metadata
      description:
        This resource allows to get complete metadata information for a particular content.
        <aside class="notice">
        Depending on the `content_type` for each parts of the content, Kivra will return either a `key` to a binary file to be retrieved or (for text based contents) the `body` of the content itself.
        </aside>
      parameters:
        - name: companyKey
          in: path
          description: The unique key for the company object being retrieved
          required: true
          schema:
            description: Company's unique key
            type: string
        - name: contentKey
          in: path
          description: The unique key for a specific content
          required: true
          schema:
            description: Content's unique key
            type: string
      security:
        - oAuth2Client:
            - "get:kivra.v1.partner.company.{companyKey}.**"
      responses:
        200:
          description: Complete metadata for the specific content
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/CompanyContent"

  # ##############################################
  # GET /v1/partner/company/COMPKEY/content/CONTKEY/file/FKEY/raw
  # ##############################################
  /v1/partner/company/{companyKey}/content/{contentKey}/file/{fileKey}/raw:
    get:
      tags:
        - "Partner API v1"
      summary: Get raw file in binary format
      operationId: Get raw file
      description: This resource allows to get the raw file in binary format.
      parameters:
        - name: companyKey
          in: path
          description: The unique key for the company object being retrieved
          required: true
          schema:
            description: Company's unique key
            type: string
        - name: contentKey
          in: path
          description: The unique key for a specific content
          required: true
          schema:
            description: Content's unique key
            type: string
        - name: fileKey
          in: path
          description: The unique key for a specific file
          required: true
          schema:
            description: File's unique key
            type: string
      security:
        - oAuth2Client:
            - "get:kivra.v1.partner.company.{companyKey}.**"
      responses:
        200:
          description: The content type will be the same as the file, so for a typical pdf it will be `application/pdf`
          content:
            application/json:
              schema:
                type: string
                format: binary

  # ##############################################
  # POST /v1/partner/company/COMPKEY/content/CONTKEY/STATUS
  # ##############################################
  /v1/partner/company/{companyKey}/content/{contentKey}/{status}:
    post:
      tags:
        - "Partner API v1"
      summary: Set status for content
      operationId: Set status for content
      description: This resource allows to set the status for a specific content. It is used by the partner to set whether the content should be marked as viewed or paid.
      parameters:
        - name: companyKey
          in: path
          description: The unique key for the company object being retrieved
          required: true
          schema:
            description: Company's unique key
            type: string
        - name: contentKey
          in: path
          description: The unique key for a specific content
          required: true
          schema:
            description: Content's unique key
            type: string
        - name: status
          in: path
          description: The specific state to be set for this content, can be `paid`, `unpaid`, `view` or `unview`
          required: true
          schema:
            description: The new state to be set for the content
            type: string
      security:
        - oAuth2Client:
            - "get:kivra.v1.partner.company.{companyKey}.**"
      responses:
        204:
          description: empty response confirming that the operation was successful
      requestBody:
        description: empty JSON body
        content:
          application/json:
            schema: {}

  # ##############################################
  # GET /v3/partner/company
  # ##############################################
  /v3/partner/company:
    get:
      tags:
        - "Partner API v3"
      summary: List accessible companies
      operationId: List companies
      description: List the companies the client has access to
      parameters:
        - name: field
          in: query
          schema:
            type: array
            items:
              $ref: '#/components/schemas/FieldQueryParameter'
        - name: vat_number
          in: query
          schema:
            type: array
            items:
              $ref: '#/components/schemas/VatNumber'
      responses:
        '200':
          description: >
            If `vat_number` is given, the repsonse will only include companies with VAT numbers in that list.
            The `field` parameter controls which columns (CSV) or properties (JSON) to include in the response.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BaseCompany'
            text/csv:
              schema:
                example: |
                  key,type,name,vat_number
                  2156077433683911cdca5fd4563bded979572454cb9,company,Cornelias
                  Café AB,SE556000475501
                type: string

  # ##############################################
  # GET /v3/partner/company/COMPKEY
  # ##############################################
  /v3/partner/company/{companyKey}:
    get:
      tags:
        - "Partner API v3"
      summary: Get a single company
      operationId: Get company
      description: Get a single company
      parameters:
        - name: companyKey
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/CompanyKey'
        - name: field
          in: query
          schema:
            type: array
            items:
              $ref: '#/components/schemas/FieldQueryParameter'
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FullCompany'

  # ##############################################
  # GET /v3/partner/company/COMPKEY/content
  # ##############################################
  /v3/partner/company/{companyKey}/content:
    get:
      tags:
        - "Partner API v3"
      summary: List company inbox content
      operationId: GET_company-companyKey-content
      description: |
        List the content this company has received.
        This may be filtered by certain `labels` and specific fields may be selected using `field`.

        Note that more content metadata is available via the
        [Get specific content](#tag/Partner-API-v3/operation/Get%20content) endpoint.
      parameters:
        - name: companyKey
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/CompanyKey'
        - name: handled
          in: query
          schema:
            $ref: '#/components/schemas/HandledLabel'
        - name: viewed
          in: query
          schema:
            $ref: '#/components/schemas/ViewedLabel'
        - name: field
          in: query
          schema:
            type: array
            items:
              $ref: '#/components/schemas/FieldQueryParameter'
      responses:
        '200':
          description: ''
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/BaseContentMetadata'

  # ##############################################
  # GET,PATCH /v3/partner/company/COMPKEY/content/CONTKEY
  # ##############################################
  /v3/partner/company/{companyKey}/content/{contentKey}:
    get:
      tags:
        - "Partner API v3"
      summary: Get specific content
      description: |
        ### Content metadata

        Get metadata about a specific content in JSON format.

        If the interpreter service is enabled for a recipient, it can add structured metadata to content which has been received.
        The `interpreted` label indicates if the interpreter has run for a given content.
        Interpreted data is never used in place of metadata provided by the sender or Kivra, it can only be added.
        Any property of the response that was added by the interpreter is clearly identified as such.
        If an interpreted property is an object, it will have an `interpreted` property which is `true`.
        If an interpreted property is a primitive value, its key path will be present in the `interpreted_fields` property.
        See the response schema below for details.

        ### Content file data

        A given content can contain multiple files ("parts"). Fetching of such parts is done by passing the `part` query parameter.

        A part can also be selected by setting the `Accept` header to the MIME type of the part you want
        (see `parts` in the metadata JSON response). You will receive the first part that matches the given
        MIME type.
      operationId: Get content
      parameters:
        - name: companyKey
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/CompanyKey'
        - name: contentKey
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/ContentKey'
        - name: part
          in: query
          schema:
            $ref: '#/components/schemas/PartQueryParameter'
      responses:
        '200':
          description: Content metadata
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FullContentMetadata'
            '*/*':
              schema:
                $ref: '#/components/schemas/ContentPart'
    patch:
      tags:
        - "Partner API v3"
      summary: Update content metadata
      operationId: Update content metadata
      parameters:
        - name: companyKey
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/CompanyKey'
        - name: contentKey
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/ContentKey'
      responses:
        '200':
          description: Content metadata
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FullContentMetadata'
            '*/*':
              schema:
                $ref: '#/components/schemas/ContentPart'
      requestBody:
        content:
          application/json:
            schema:
              additionalProperties: false
              properties:
                handled:
                  description: Mark the content as `handled`/`unhandled`
                  $ref: '#/components/schemas/HandledLabel'
                viewed:
                  description: Mark the content as `viewed`/`unviewed`
                  $ref: '#/components/schemas/ViewedLabel'
              type: object
        required: true

components:
  schemas:
    # ##############################################
    # SCHEMA Content_user
    # ##############################################
    Content_user:
      type: object
      properties:
        ssn:
          description: |
            User's unique SSN, according to the `YYYYMMDDnnnn` format
          type: string
          writeOnly: true
          example: "191212121212"
        email:
          description: |
            A kivra user's verified email address.
          type: string
          writeOnly: true
          example: "Kivra.Sweden@example.com"
        subject:
          description: |
            The subject/title will be visibile in the Recipients Inbox.
            Keep the subject short and concise (i.e. up to 30-35 characters) to make sure that is fully visible on most screen sizes.
            Avoid using personal and sensitive information in the subject.
          type: string
          example: "Invoice for March 2022"
        generated_at:
          type: string
          format: ISO8601
          example: "2022-12-31"
          description: |
            Optional attribute which denotes when a specific Content was generated at the tenant/integrator’s site.
            The attribute will be used for sorting in the Kivra user interface, which makes it possible for a tenant or integrator to control the sorting.
        type:
          type: string
          example: "letter"
          description: |
            Optional attribute providing information about the type of content being sent.
            The type of a content may influence how the user interacts with the content and how the user is notified about the content.
            Allowed values are:
            - `"letter"`: |
              indicating that the content is an information letter. This is the default type for all non-payable content.
            - `"letter.salary"`: |
              indicating that the content is a salary specification.
            - `"letter.creditnotice"`: |
              indicating that the content is a creditnotice.
            - `"invoice"`: |
              indicating that the content is an invoice. A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
              This is the default type for all payable content.
            - `"invoice.reminder"`: |
              indicating that the content is an invoice, a reminder for a previously unpaid invoice.
              The invoice might include late fees and other differences compared to the original invoice.
              A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
            - `"invoice.debtcampaign"`: |
              indicating that the content is an invoice or payment plan from a debt collection company.
              The invoice might include fees such as interest and reminder fees.
              A valid "payment" object needs to be provided and the "payable" attribute must be set to "true".
              This content type enables long due dates with a longer notification scheme
            - `"invoice.renewal"`: |
              indicating that the content is not a real invoice, but an offer that is voluntary to pay for the receiver.
              It can be used to send an offer to renew a subscription, insurance or similar.
              A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
            - `"invoice.debtcollection"`: |
                indicating that the content is a debt collection claim (in Swedish: "inkassokrav").
                A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
            - `"booking"`: |
            indicating that the content is a booking/appointement.
        retain:
          description: |
            Boolean denoting if Kivra should try and retain this Content if it can’t be delivered. Default `false`.
            Please note that retain must never be set to `true` for payable content.
          type: boolean
          writeOnly: true
          example: false
        retention_time:
          description: |
            How long to retain a Content. Supported values: `"30"` and `"390"`
          type: string
          writeOnly: true
          example: "30"
          enum: ["30", "390"]
        files:
          description: Array of file Objects
          type: array
          writeOnly: true
          items:
            $ref: "#/components/schemas/File"
        context:
          type: object
          writeOnly: true
          description: Optionally specify additional information
          properties:
            invoice:
              type: object
              description: Optionally specify invoice information
              properties:
                payment_or_payment_multiple_options:
                  oneOf:
                    - $ref: "#/components/schemas/Payment"
                    - $ref: "#/components/schemas/PaymentMultipleOptions"
                invoice_reference:
                  type: string
                  description: Tenant’s own Invoice Reference
                  example: "Invoice Nr #123"
            booking:
              description: Optionally specify booking information
              $ref: "#/components/schemas/Booking"

    # ##############################################
    # SCHEMA Content_user_v2
    # ##############################################
    Content_user_v2:
      type: object
      properties:
        ssn:
          description: |
            User's unique SSN, according to the `YYYYMMDDnnnn` format
          type: string
          writeOnly: true
          example: "191212121212"
        email:
          description: |
            A kivra user's verified email address.
          type: string
          writeOnly: true
          example: "Kivra.Sweden@example.com"
        subject:
          description: |
            The subject/title will be visibile in the Recipients Inbox.
            Keep the subject short and concise (i.e. up to 30-35 characters) to make sure that is fully visible on most screen sizes.
            Avoid using personal and sensitive information in the subject.
          type: string
          example: "Invoice for March 2022"
        generated_at:
          type: string
          format: ISO8601
          example: "2022-12-31"
          description: |
            Optional attribute which denotes when a specific Content was generated at the tenant/integrator’s site.
            The attribute will be used for sorting in the Kivra user interface, which makes it possible for a tenant or integrator to control the sorting.
        type:
          type: string
          example: "letter"
          description: |
            Optional attribute providing information about the type of content being sent.
            The type of a content may influence how the user interacts with the content and how the user is notified about the content.
            Allowed values are:
            - `"letter"`: indicating that the content is an information letter. This is the default type for all non-payable content.
            - `"letter.salary"`: indicating that the content is a salary specification.
            - `"letter.creditnotice"`: indicating that the content is a creditnotice.
            - `"invoice"`: |
              indicating that the content is an invoice. A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
              This is the default type for all payable content.
            - `"letter.form"`: indicating that the content contains a form.
            - `"invoice.reminder"`: |
              indicating that the content is an invoice, a reminder for a previously unpaid invoice.
              The invoice might include late fees and other differences compared to the original invoice.
              A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
            - `"invoice.debtcampaign"`: |
              indicating that the content is an invoice or payment plan from a debt collection company.
              The invoice might include fees such as interest and reminder fees. A valid "payment" object needs to be provided and the "payable" attribute must be set to "true".
              This content types enables long due dates with a longer notification scheme
            - `"invoice.renewal"`: |
              indicating that the content is not a real invoice, but an offer that is voluntary to pay for the receiver.
              It can be used to send an offer to renew a subscription, insurance or similar. A valid "payment" object needs to be provided and the "payable" attribute must be set to true.
            - `"booking"`: indicating that the content is a booking/appointement.
        retain:
          description: |
            Boolean denoting if Kivra should try and retain this Content if it can’t be delivered. Default `false`.
            Please note that retain must never be set to `true` for payable content.
          type: boolean
          writeOnly: true
          example: false
        retention_time:
          description: |
            How long to retain a Content. Supported values: `"30"` and `"390"`
          type: string
          writeOnly: true
          example: "30"
          enum: ["30", "390"]
        parts:
          description: Array of file Objects
          type: array
          writeOnly: true
          items:
            $ref: "#/components/schemas/Parts_Responsive"
        payment:
          type: object
          description: Optionally specify invoice information, please notice that you cannot have both payment and payment_multiple_options in the same payload
          $ref: "#/components/schemas/Payment"
        payment_multiple_options:
          type: object
          description: Optionally specify multiple payment options, please notice that you cannot have both payment and payment_multiple_options in the same payload
          $ref: "#/components/schemas/PaymentMultipleOptions"
        booking:
          description: Optionally specify booking information
          $ref: "#/components/schemas/Booking"
        form:
          description: Optionally attach a form
          $ref: "#/components/schemas/Form"
        campaign:
          description: Optionally attach a campaign
          $ref: "#/components/schemas/Campaign"


    # ##############################################
    # SCHEMA Form Template
    # ##############################################
    FormTemplate:
      type: object
      required:
        - title
        - description
        - fields
        - form_template_key
        - tenant_key
        - created_at
      properties:
        title:
          type: string
          description: |
            The title of the form.
          example: Customer KYC
        description:
          type: string
          description: |
            The purpose of the form.
          example: Your bank has some questions
        fields:
          type: array
          description: |
            The questions that you want to ask the user.
          items:
            $ref: "#/components/schemas/FormField"
          example:
            - label: How many times per month do you deposit into your account?
              name: number_deposits
              type: number
            - label: What is the largest amount deposited?
              name: largest_sum
              type: options
              values:
                - id: small
                  label: 10000 - 20000
                - id: medium
                  label: 20000 - 30000
                - id: large
                  label: 30000 - 40000
            - label: Do you have any further comments?
              name: comments
              type: free_text
              help_text: This can be any type of feedback that you have.
        form_template_key:
          type: string
          format: uuid
          description: |
            The id of the newly created form template.
          readOnly: true
          example: "2877d684-a340-4e4c-867f-d93283787b01"
        tenant_key:
          type: string
          format: hexadecimal
          description: |
            The tenant key of the tenant that created the form template.
          readOnly: true
          example: "1341543157b3a8c66f220b2164b2e13789d2d04015"
        created_at:
          type: string
          description: |
            The date the form template was created.
          readOnly: true
          example: "2022-11-23T14:51:23.874434Z"
    FormField:
      type: object
      required:
        - type
        - label
        - name
      properties:
        type:
          type: string
          enum: [free_text, number, options]
          description: |
            The input type required to answer the question.

            `free_text` is a string.

            `number` is an integer or a floating point number.

            `options` is a string that has a finite amount of values e.g. yes or no question.
        label:
          type: string
          description: |
            Human readable description of what the question is.
        name:
          type: string
          description: |
            A key used to identify the question.
        help_text:
          type: string
          description: |
            Provides the user with more information about the question.
        values:
          type: array
          description: |
            When `type` is `options` then use this to specify the answers that the user can select.
          items:
            $ref: "#/components/schemas/FormOption"
    FormOption:
      type: object
      required:
        - id
        - label
      properties:
        id:
          type: string
          description: |
            A key used to identify the answer.
        label:
          type: string
          description: |
            A human readable description of the answer.
    FormTemplateKey:
      type: object
      required:
        - form_template_key
      properties:
        form_template_key:
          type: string
          description: |
            A key used to identify the form template.
          example:
            2877d684-a340-4e4c-867f-d93283787b01

    # ##############################################
    # SCHEMA Form Response
    # ##############################################
    FormResponseKeys:
      type: object
      required:
        - form_template_key
        - responses
      properties:
        form_template_key:
          type: string
          format: uuid
          description: |
            The form template key associated with the form responses.
          example:
            2877d684-a340-4e4c-867f-d93283787b01
        responses:
          type: array
          description: |
            Metadata about the form response
          items:
            type: object
            properties:
              form_response_key:
                type: string
                format: uuid
                description: |
                  A key used to identify the individual form response.
                example:
                  bed773d7-9029-42f2-9f0b-0729390c962c
    FormResponse:
      type: object
      required:
        - form_response_key
        - form_template_key
        - responses
        - matched_by
        - login_method
        - responded_at
        - sender_reference
      properties:
        form_response_key:
          type: string
          format: uuid
          description:
              The form response key
          example:
            2877d684-a340-4e4c-867f-d93283787b01
        form_template_key:
          type: string
          format: uuid
          description:
             The form template key.
          example:
            2877d684-a340-4e4c-867f-d93283787b01
        responses:
          type: object
          description:
            The form response that the user submitted.
          required:
            - name
            - value
            - type
          properties:
            name:
              type: string
              description: |
                A key used to identify the question.
            value:
              type: object
              additionalProperties:
                oneOf:
                  - type: string
                  - type: number
              description: |
                The response to the question.
            type:
              type: string
              enum: [free_text, number, options]
              description: |
                The input type required to answer the question.

                `free_text` is a string.

                `number` is an integer or a floating point number.

                `options` is a string that has a finite amount of values e.g. yes or no question.
          example:
             - name: number_deposits
               value: 1
               type: number
             - name: largest_sum
               value: small
               type: options
             - name: comments
               value: No further comments
               type: free_text
        matched_by:
          type: object
          description:
            Used to identify the user that answered the form
          required:
            - type
            - value
          properties:
            type:
              type: string
              enum: [ssn, email]
              description:
                How the user that answered the form was identified.
              example: ssn
            value:
              type: string
              description:
                Represents a value used to identify a user e.g. ssn or email.
              example: 199202286837
        login_method:
          type: string
          enum: [bankid]
          description:
                How the user that submitted the form logged into Kivra
          example: bankid
        responded_at:
          type: string
          format: ISO8601
          description:
                When Kivra received a response to the form
          example: 2023-08-22T12:39:29.000000Z
        sender_reference:
          type: object
          nullable: true
          description: Provided reference data in content sendout is included in the form response.
          example:
            internal_id: "6eb7d1b9-ccd6-408f-ade7-9a1837be3ecf"
    BasicErrorResponse:
      type: object
      required:
        - code
        - short_message
        - long_message
      properties:
        code:
          type: integer
          description: An error code identifying the reason of the unsuccessful request.
        short_message:
          type: string
          description: Short human-readable description.
        long_message:
          type: string
          description: Longer human-readable description getting into details.
    FormErrorResponse:
      allOf:
        - $ref: "#/components/schemas/BasicErrorResponse"
        - type: object


    # ##############################################
    # SCHEMA Content_company
    # ##############################################
    Content_company:
      type: object
      required:
        - vat_number
      properties:
        vat_number:
          description: |
            A valid VAT-identifier, Swedish format: `SE[xxxxxxxxxx]01`
          type: string
          writeOnly: true
          example: SE556840226601
        subject:
          description: This Subject/Title will be visibile in the Recipients Inbox.
          type: string
          example: "Sample Invoice"
        generated_at:
          type: string
          format: ISO8601
          example: "2016-12-12"
          description: |
            Optional attribute which denotes when a specific Content was generated at the tenant/integrator’s site. The attribute will be used for sorting in the Kivra user interface, which makes it possible for a tenant or integrator to control the sorting.
        type:
          type: string
          example: "letter"
          description: |
            Optional attribute providing information about the type of content being sent. The type of a content may influence how the user interacts with the content and how the user is notified about the content.
              Allowed values are:
              - `"letter"`: indicating that the content is an information letter. This is the default type for all non-payable content.
              - `"invoice"`: indicating that the content contains payment information. This value can only be used when a "payment" object is provided and the "payable" attribute is set to true. This is the default type for all payable content.
              - `"letter.salary"`: indicating that the content is a salary specification.
              - `"letter.creditnotice"`: indicating that the content is a creditnotice.
        files:
          description: Array of file Objects
          type: array
          writeOnly: true
          items:
            $ref: "#/components/schemas/File"
        context:
          type: object
          writeOnly: true
          description: Optionally specify additional information
          properties:
            invoice:
              type: object
              description: Optionally specify invoice information
              properties:
                payment:
                  $ref: "#/components/schemas/Payment"
                invoice_reference:
                  type: string
                  description: Tenant’s own Invoice Reference
                  example: "Invoice Nr #123"

    # ##############################################
    # SCHEMA Payment
    # ##############################################
    Payment:
      type: object
      description: Optionally specify payment information
      required:
        - payable
        - currency
        - due_date
        - total_owed
        - type
        - method
        - account
        - reference
      properties:
        payable:
          type: boolean
          description: Toggles whether this content should be payable through Kivra’s payment platform
        status:
          type: string
          description: "Toggles whether this content is paid or unpaid: if already paid the user can’t pay it again through Kivra"
          default: "unpaid"
          readOnly: true
          enum: ["paid", "unpaid"]
        currency:
          type: string
          enum:
            - SEK
          example: "SEK"
          description: |
            Currency used in specifying `total_owed`. In Sweden, only SEK is accepted.
        due_date:
          type: string
          format: ISO8601
          example: "2017-01-01"
          description: Date when this Invoice is due
        total_owed:
          type: string
          format: float
          example: "123.50"
          description: The total amount owed according to the invoice. **If `payable` equals `true` this must be a non negative number that’s greater than "0"**
        type:
          type: string
          description: Type of format for the reference
          example: "SE_OCR"
          enum: ["SE_OCR", "TENANT_REF"]
        method:
          type: string
          description: 1 = BG and 2 = PG
          example: "1"
          enum: ["1", "2"]
        account:
          type: string
          example: "12345"
          description: Tenant’s account number
        reference:
          type: string
          example: "426523791"
          description: The reference number used for paying. This can be maximum 25 characters long
        variable_amount:
          type: boolean
          default: false
          description: Toggles whether the user may choose to pay only a portion of the total_owed amount or whether the user must always pay the complete total_owed amount
        min_amount:
          type: string
          format: float
          example: "50.00"
          description: The minimum amount that can be paid when `variable_amount` equals `true`. Note that this is a soft limit, so whenever `variable_amount` is `true` the user will be able to choose freely the amount to be paid, but it may be warned if the amount paid is inferior to `min_amount`. `min_amount` must be greater than "0" and less than "total_owed".

    # ##############################################
    # SCHEMA PaymentMultipleOptions
    # ##############################################
    PaymentMultipleOptions:
      type: object
      description: Payment information when multiple options are available. Note that the first options is special. Notifications about the invoice will be based on the due date specified in the first option, and in the case where a user looks at the invoice in a client that does not know about multiple options, the first one will be the only one presented. For example, if the invoice offers the choice of paying the entire debt or to start a payment plan, the first option should be to pay the entire debt.
      required:
        - payable
        - account
        - method
        - currency
        - options
      properties:
        payable:
          type: boolean
          description: Toggles whether this content should be payable through Kivra’s payment platform. Only `true` is allowed when sending multiple payment options.
          enum: [true]
        status:
          type: string
          description: "Toggles whether this content is paid or unpaid: if already paid the user can’t pay it again through Kivra"
          default: "unpaid"
          readOnly: true
          enum: ["paid", "unpaid"]
        method:
          type: string
          description: 1 = BG and 2 = PG
          example: "1"
          enum: ["1", "2"]
        account:
          type: string
          example: "1234-5678"
          description: |
            The destination account number if the user choses to pay this
            invoice with a service that uses some variety of bank transfer (for
            example, BankGiro or PlusGiro).
        swish_alias:
          type: string
          description: |
            The Swish Payee Alias that should be used as the recipient if the
            user choses to pay this invoice with Swish. The alias given must be
            one that is listed as available for the sender, or it will be
            ignored. The value can also be the string `disable`, in order to
            override a default payee alias and disable Swish payment for this
            invoice only. This functionality will be released in Q2 2023.
        currency:
          type: string
          enum:
            - SEK
          example: "SEK"
          description: |
            Currency used in specifying `amount`. In Sweden, only SEK is allowed.
        options:
          type: array
          description: "A list of payment options, where each option should differ in either `amount` or `reference`"
          items:
            type: object
            description: "A payment option where each option should differ in either `amount` or `reference`"
            required:
              - due_date
              - amount
              - type
              - reference
            properties:
              due_date:
                type: string
                format: ISO8601
                example: "2017-01-01"
                description: Date when this option is due.
              amount:
                type: string
                format: float
                example: "123.50"
                description: The payment amount for this option. A positive number.
              type:
                type: string
                description: Type of format for the reference
                example: "SE_OCR"
                enum: ["SE_OCR", "TENANT_REF"]
              reference:
                type: string
                example: "426523791"
                description: The reference number used for paying. This can be maximum 25 characters long.
              title:
                type: string
                description: "Title for this option"
              description:
                type: string
                description: "Optional description for this option"
              icon:
                $ref: '#/components/schemas/PaymentOptionIcon'
        flexible_option:
          type: object
          description: "A flexible payment option."
          required:
            - due_date
            - type
            - reference
          properties:
            due_date:
              type: string
              format: ISO8601
              example: "2017-01-01"
              description: Date when this option is due.
            type:
              type: string
              description: Type of format for the reference
              example: "SE_OCR"
              enum: ["SE_OCR", "TENANT_REF"]
            reference:
              type: string
              example: "426523791"
              description: The reference number used for paying. This can be maximum 25 characters long.
            title:
              type: string
              description: "Title for this option"
            description:
              type: string
              description: "Optional description for this option"
            icon:
              $ref: '#/components/schemas/PaymentOptionIcon'
            min_limit:
              type: string
              format: float
              example: "123.50"
              description: The smallest allowed amount to be paid. If not given it defaults to 1.00 SEK.
            min_suggested:
              type: string
              format: float
              example: "123.50"
              description: The user is encouraged to pay more than this amount.
            max_suggested:
              type: string
              format: float
              example: "123.50"
              description: The user is encouraged to not pay more than this amount.
            max_limit:
              type: string
              format: float
              example: "123.50"
              description: The largest allowed amount to be paid. Note that even if this amount is not given or very high, limits from the payment provider or bank will still apply.


    # ##############################################
    # SCHEMA CompanyList
    # ##############################################
    CompanyList:
      type: object
      properties:
        key:
          description: Company's unique Key
          type: string
          example: "15236156848eefa1dc75364af2be38c98eb3aae223"
        vatnr:
          description: Company's unique Vat Number
          type: string
          example: "SE556840226601"

    # ##############################################
    # SCHEMA UserList
    # ##############################################
    UserList:
      type: object
      properties:
        key:
          description: This field is no longer used
          type: string
          example: ""
        ssn:
          description: User's unique SSN in the form `YYYYMMDDnnnn`
          type: string
          example: "191212121212"

    # ##############################################
    # SCHEMA UserDiff
    # ##############################################
    UserDiff:
      type: object
      properties:
        added:
          type: array
          description: List of added users
          items:
            $ref: "#/components/schemas/UserList"
        removed:
          type: array
          description: List of removed users
          items:
            $ref: "#/components/schemas/UserList"

    # ##############################################
    # SCHEMA UserMatch
    # ##############################################
    UserMatch:
      required:
        - ssns
      type: object
      properties:
        ssns:
          type: array
          items:
            type: string
            example:
              - "191212121212"
              - "197701032380"
              - "198112172385"
          description: list of SSNs to be matched
      example:
        ssns:
          - "191212121212"
          - "197701032380"
          - "198112172385"

    # ##############################################
    # SCHEMA V2 UserMatch
    # ##############################################
    UserMatchV2SSN:
      required:
        - list
      type: object
      properties:
        list:
          type: array
          items:
            type: string
            example:
              - "191212121212"
              - "197701032380"
              - "198112172385"
          description: list of recipient addresses to be matched
      example:
        list:
          - "191212121212"
          - "197701032380"
          - "198112172385"

    UserMatchV2Email:
      required:
        - list
      type: object
      properties:
        list:
          type: array
          items:
            type: string
            example:
              - "fOO@example.com"
              - "bAr@EXAMPLE.COM"
          description: list of recipient addresses to be matched
      example:
        list:
          - "fOO@example.com"
          - "bAr@EXAMPLE.COM"

    # ##############################################
    # SCHEMA CompanyMatch
    # ##############################################
    CompanyMatch:
      required:
        - vat_numbers
      type: object
      properties:
        vat_numbers:
          type: array
          items:
            type: string
            example:
              - "SE25555555550"
              - "SE25555555551"
              - "SE25555555552"
          description: list of VAT Numbers
      example:
        vat_numbers:
          - "SE25555555550"
          - "SE25555555551"
          - "SE25555555552"

    # ##############################################
    # SCHEMA Tenant_v2
    # ##############################################
    Tenant_v2:
      type: object
      required:
        - name
        - company_id
      properties:
        name:
          description: Name of the Tenant, this name shows up in the Users Inbox
          type: string
          example: "Kivra"
        company_id:
          type: array
          items:
            $ref: "#/components/schemas/CompanyId"
        edit_security_level:
          description: Security level needed for an enduser to `opt_out` from this Tenant
          type: integer
          readOnly: true
          example: 50
          enum: [25, 50]
        groups:
          type: array
          items:
            type: string
          readOnly: true
          description: List of groups this Tenant belongs to
          example: []
        visibility:
          description: Determines if this Tenant is visible for the enduser
          type: string
          readOnly: true
          enum: [visible, hidden]
        created_at:
          description: Datum when the tenant was created in UTC format
          type: string
          readOnly: true
          example: "2019-05-20T12:42:29Z"
        created_by:
          description: ID of client that created the tenant
          type: string
          readOnly: true
          example: "client_15063298495eafd2749bb78e2f991af3ab023d13df"
        status:
          description: internal field describing whether the user can opt-out the tenant
          type: string
          readOnly: true
          example: "optional"
        class:
          description: internal field
          type: string
          readOnly: true
          example: "opt_out"

    # ##############################################
    # SCHEMA Error40915
    # ##############################################
    Error40915:
      type: object
      properties:
        code:
          type: string
          description: The 5-digits error code
          example: 40915
        short_message:
          type: string
          description: A short message explaining the conflict
          example: Orgnumber already exist
        long_message:
          type: string
          description: A text message explaining the conflict
          example: "One or more of the organisation numbers within the company_id's you provided, already exist in existing tenants. Tenants outside your scope: {Name: TestBolag, Tenant key: 1424780396902ee9278b16417f8e3252c3ced28c38, Organisation number: SE556840226601}"

    # ##############################################
    # SCHEMA Error40045
    # ##############################################
    Error40045:
      type: object
      properties:
        code:
          type: string
          description: The 5-digits error code
          example: 40045
        short_message:
          type: string
          description: A short message explaining the error
          example: PDF was invalid
        long_message:
          type: string
          description: A text message explaining the error
          example: The supplied agreement PDF was invalid. Please check that the file is a valid PDF

    # ##############################################
    # SCHEMA RequestAccess
    # ##############################################
    RequestAccess:
      type: object
      properties:
        created_at:
          description: Datum when the request was created in UTC format
          type: string
          readOnly: true
          example: "2019-05-20T12:42:29Z"
        created_by:
          description: ID of client that created the request
          type: string
          readOnly: true
          example: "client_15063298495eafd2749bb78e2f991af3ab023d13df"
        status:
          description: internal field describing whether the user can opt-out the tenant
          type: string
          readOnly: true
          example: "pending"
        client_id:
          description: ID Of You the Client
        client_name:
          description: Name of the client who created the requested tenant
          type: string
          readOnly: true
          example: "Client XYZ"
        tenant_name:
          description: Name of the requested tenant
          type: string
          readOnly: true
          example: "Tenant ABC"
        tenant_key:
          description: Key of the requested tenant
          type: string
          readOnly: true
          example: "1424780396902ee9278b16417f8e3252c3ced28c38"

    # ##############################################
    # SCHEMA Agreement
    # ##############################################
    Agreement:
      type: object
      required:
        - subject
        - type
        - original
        - parties
      properties:
        subject:
          description: Name of the agreement
          type: string
          example: "Employment agreement"
        type:
          description: the type of content, for agreements always use 'agreement'
          type: string
          example: "agreement"
        vat_number:
          description: |
            A valid VAT-identifier, Swedish format: `SE[xxxxxxxxxx]01`
          type: string
          example: SE556840226601
        original:
          type: object
          properties:
            name:
              description: Name of the document file
              type: string
              example: "agreement1025.pdf"
            content_type:
              description: The [IANA](http://www.iana.org/assignments/media-types/media-types.xhtml) media type corresponding to the file, e.g. "application/pdf"
              type: string
              example: "application/pdf"
            data:
              description: Base64-encoded data for the agreement PDF
              type: string
              format: "Base64-encoded data"
              example: REVBREJFRUY=
        parties:
          description: list of signers and delegates that are requested to sign the agreement
          type: array
          items:
            $ref: "#/components/schemas/AgreementParties"
          example:
            - ssn: "197701032380"
              name: "Jan-Erik Karlsson"
              email: "je.karlsson@email.nu"
              role: "signer"
            - ssn: "198112172385"
              name: "Gustav Larsson"
              email: "gustav123@mymail.com"
              role: "delegate"

    # ##############################################
    # SCHEMA AgreementParties
    # ##############################################
    AgreementParties:
      type: object
      properties:
        ssn:
          description: |
            User's unique SSN, format: `YYYYMMDDnnnn`
          type: string
          example: "197701032380"
        name:
          description: Name of the user
          type: string
          example: "Jan-Erik Karlsson"
        email:
          description: email to be used to contact the user
          type: string
          example: "je.karlsson.hem@email.nu"
        role:
          description: the role of the user in this signature flow
          type: string
          enum: ["signer", "delegate"]
          example: "signer"

    # ##############################################
    # SCHEMA AgreementStateShort
    # ##############################################
    AgreementStateShort:
      type: object
      properties:
        key:
          description: unique agreement id
          type: string
          example: "1544707148d73a3e84a216427724637fc207cba2ab"
        state:
          description: current state for the agreement
          type: string
          example: "active"
          enum: [active, generating, completed, revoked]
          readOnly: true

    # ##############################################
    # SCHEMA AgreementStateDetailed
    # ##############################################
    AgreementStateDetailed:
      type: object
      properties:
        subject:
          description: Name of the agreement
          type: string
          example: "Employment agreement"
        created_at:
          description: The time when the agreement was created
          type: string
          example: "2019-04-09T13:42:26Z"
          readOnly: true
        expires_at:
          description: |
            The expiration time for the agreement, if the agreement is not completed before this date, it will no longer be available for signature
          type: string
          example: "2019-05-09T13:42:26Z"
          readOnly: true
        state:
          description: The current state of the agreement
          type: string
          example: completed
          enum: [active, generating, completed, revoked]
          readOnly: true
        tenant_name:
          description: The name of the tenant that created the agreement
          type: string
          example: "Sender AB"
        tenant:
          description: The tenant key that created the agreement
          type: string
          example: "tenant_154442474745511bbaaa5b44b391eae0513e2c55a0"
        type:
          description: The type of agreement as provided by the sender when the agreement was created
          type: string
          example: "agreement"
        signatures:
          description: |
            List of signatures
          type: array
          readOnly: true
          items:
            $ref: "#/components/schemas/AgreementSignature"
          example:
            - ssn: "197701032380"
              real_name: "Jan-Erik Karlsson"
              created_at: "2019-04-12T08:23:29Z"
              order_ref: "d4ace777-6b91-4172-903e-39371ede89f1"
            - ssn: "198112172385"
              real_name: "Gustav Johan Larsson"
              created_at: "2019-04-11T18:53:03Z"
              order_ref: "f5bce777-0b42-4222-1f3e-ab523ede7a5f"
        parties:
          description: list of signers and delegates that are requested to sign the agreement
          type: array
          items:
            $ref: "#/components/schemas/AgreementParties"
          example:
            - ssn: "197701032380"
              name: "Jan-Erik Karlsson"
              email: "je.karlsson.hem@email.nu"
              role: "signer"
            - ssn: "198112172385"
              name: "Gustav Larsson"
              email: "gustav123@mymail.com"
              role: "delegate"

    # ##############################################
    # SCHEMA AgreementSignature
    # ##############################################
    AgreementSignature:
      type: object
      properties:
        ssn:
          description: |
            Signer's unique SSN, format: `YYYYMMDDnnnn`
          type: string
          example: "191212121212"
        real_name:
          description: The real name of the signer, as provided by Mobile BankID service
          type: string
          example: "Jan-Erik Karlsson"
        created_at:
          description: The time when the signature was created
          type: string
          example: "2019-04-12T08:23:29Z"
        order_ref:
          description: The unique ID of the signature
          type: string
          example: "d4ace777-6b91-4172-903e-39371ede89f1"

    # ##############################################
    # SCHEMA CompanyId
    # ##############################################
    CompanyId:
      type: object
      required:
        - name
        - orgnr
      properties:
        name:
          description: Legal name of Company
          type: string
          example: "Kivra AB"
        orgnr:
          description: Vat number of Company
          type: string
          example: "SE556840226601"

    # ##############################################
    # SCHEMA File
    # ##############################################
    File:
      type: object
      required:
        - name
        - data
        - content_type
      properties:
        name:
          description: Arbritrary file-name that is shown alongside the File in the Kivra GUI
          type: string
          example: filename.pdf
        data:
          description: Base64-encoded data
          type: string
          format: "Base64-encoded data"
          example: REVBREJFRUY=
        content_type:
          description: The [IANA](http://www.iana.org/assignments/media-types/media-types.xhtml) media type corresponding to the file, e.g. "application/pdf"
          type: string
          example: "application/pdf"

    # ##############################################
    # SCHEMA Parts_Responsive
    # ##############################################
    Parts_Responsive:
      type: object
      required:
        - name
        - data
        - content_type
      properties:
        name:
          description: Arbritrary file-name
          type: string
          example: document.pdf
        data:
          description: Base64-encoded data for the PDF content
          type: string
          format: "Base64-encoded data"
          example: REVBREJFRUY=
        content_type:
          description: The [IANA](http://www.iana.org/assignments/media-types/media-types.xhtml) media type for PDF files "application/pdf"
          type: string
          example: "application/pdf"
        responsive_part:
          type: object
          required:
            - name
            - data
            - content_type
          properties:
            name:
              description: Arbritrary file-name
              type: string
              example: document.html
            data:
              description: Base64-encoded data for the HTML document
              type: string
              format: "Base64-encoded HTML data"
              example: PGgxPmNvbnRlbnQgMTwvaDE+CjxwPmNvbnRlbnQgMTwvcD4=
            content_type:
              description: The [IANA](http://www.iana.org/assignments/media-types/media-types.xhtml) media type for HTML content "text/html"
              type: string
              example: "text/html"

    # ##############################################
    # SCHEMA Icon
    # ##############################################
    Icon:
      type: object
      required:
        - data
        - content_type
      properties:
        name:
          description: Arbitrary filename
          type: string
          example: filename.pdf
        data:
          description: >
            Base64-encoded data. Max size is 134 kB when encoded which is roughly equivalent to
            100 kB before encoding. The image format must be PNG.
            The image must be quadratic (that is, width and height
            must be the same). The sides must be at least 256
            pixels long, and at most 512 pixels long. The image
            must have an alpha channel.
          type: string
          format: "Base64-encoded data"
          example: REVBREJFRUY=
        content_type:
          description: The [IANA](http://www.iana.org/assignments/media-types/media-types.xhtml) media type corresponding to the file, e.g. "image/png"
          type: string
          enum: ["image/png"]
          example: "image/png"

    # ##############################################
    # SCHEMA TenantIcon
    # ##############################################
    TenantIcon:
      allOf:
        - $ref: "#/components/schemas/Icon"
        - type: object
          properties:
            data:
              description: Base64-encoded data
              type: string
              format: "Base64-encoded data"
              example: REVBREJFRUY=

    # ##############################################
    # SCHEMA PaymentOptionIcon
    # ##############################################
    PaymentOptionIcon:
      allOf:
        - $ref: "#/components/schemas/Icon"
        - type: object
          properties:
            data:
              # TODO: Actually decide max before merging this PR
              description: This string is ignored by the documentation system
              type: string
              example: REVBREJFRUY=

    # ##############################################
    # SCHEMA CompanyInbox
    # ##############################################
    CompanyInbox:
      type: object
      properties:
        key:
          description: Content's unique key
          type: string
          example: "15294092505b9cfab3f79d233f8eca6fbc5385fa61"
        sender:
          description: Unique key for the tenant that posted the content
          type: string
          example: "1341573157b3a133f220f4217b2e32989d2efa015"
        sender_name:
          description: Name of the tenant that posted the content
          type: string
          example: "Kivra"
        created_at:
          description: Date and time when the content was delivered to the recipient
          type: string
          example: "2018-06-19T11:54:10Z"
        subject:
          description: Subject of the content, as set by the sender
          type: string
          example: "Invoice 4512 from Local Bank"
        status:
          description: Whether the content has been read (opened) or not
          type: string
          enum: ["read", "unread"]
          example: "read"

    # ##############################################
    # SCHEMA CompanyContent
    # ##############################################
    CompanyContent:
      type: object
      properties:
        sender:
          description: Unique key for the tenant that posted the content
          type: string
          example: "1341573157b3a133f220f4217b2e32989d2efa015"
        sender_name:
          description: Name of the tenant that posted the content
          type: string
          example: "Kivra"
        created_at:
          description: Date and time when the content was delivered to the recipient
          type: string
          example: "2018-06-19T11:54:10Z"
        subject:
          description: Subject of the content, as set by the sender
          type: string
          example: "Invoice 4512 from Local Bank"
        receiver_name:
          description: Name of the company that received the content
          type: string
          example: "Digital Hero AB"
        payment:
          $ref: "#/components/schemas/Payment"
        parts:
          description: files composing the content
          type: array
          items:
            $ref: "#/components/schemas/Parts"

    # ##############################################
    # SCHEMA Booking
    # ##############################################
    Booking:
      type: object
      required:
        - title
        - start_time
      properties:
        title:
          description: |
            Booking name that is used when creating a post in an external calendar. Note! Don’t include any sensitive information here.
          type: string
          example: "Kontroll av tandhälsa"
        start_time:
          description: |
            Date and time for the booking to start. Must be in the future. If the time zone is not stated it will be set to UTC.
          type: string
          format: ISO8601
          example: "2028-06-19T11:00:00Z"
        end_time:
          description: |
            Date and time for the booking to end. If present must be after start_time. If the time zone is not stated it will be set to UTC.
          type: string
          format: ISO8601
          example: "2028-06-19T12:00:00Z"
        location:
          description: Location for the appointment/booking. Address must contain city for full functionality.
          type: string
          example: "Strandvägen 61, Stockholm"
        description:
          description: |
            Additional information. Note! Don’t include any sensitive information here.
          type: string
          example: "Brush your teeth before coming"
        info_url:
          description: Link to page with additional information
          type: string
          format: uri

    # ##############################################
    # SCHEMA Form
    # ##############################################
    Form:
      required:
        - id
        - days_to_expiry
      type: object
      properties:
        id:
          type: string
          format: uuid
          description: The form template key
          example: 2877d684-a340-4e4c-867f-d93283787b01
        sender_reference:
          type: object
          description: Reference data you want to include in the form response.
          example:
            internal_id: "6eb7d1b9-ccd6-408f-ade7-9a1837be3ecf"
        days_to_expiry:
          type: integer
          minimum: 1
          maximum: 90
          description: >
            Number of days in which a response to the form can be submitted
            (until 23:59:59).

            As an *example*, if *the content is sent* on September 8th,
            and the form expires in 30 days, it will effectively expire
            on October 7th 23:59:59.
          example: 30

    # ##############################################
    # SCHEMA Campaign
    # ##############################################
    Campaign:
      type: object
      description: This is BETA and only available in Sandbox. As such this may change.
      required:
        - tag
      properties:
        tag:
          type: string
          description: The tag that refers to the campaign that you want to attach. Note that the request will still be processed even if the campaign does not exist.
          example: summer_2023

    # ##############################################
    # SCHEMA Parts
    # ##############################################
    Parts:
      type: object
      properties:
        content_type:
          type: string
          description: The IANA media type corresponding to the file, e.g. "application/pdf"
          example: "application/pdf"
        checksum:
          type: string
          description: The cheksum of the document calculated with md5
          example: "9209c7eebdd283a4c4bd7555e73e6064"
        sha256:
          type: string
          description: hash of the document calculated with SHA-256
          example: "287f2fe67a8a76a10169aa6a885d21e1f83416c4831294ea5c4b0a38bda5c78d"
        size:
          type: integer
          description: size of the document in bytes
          example: 163414
        body:
          type: string
          description: body of the content (present only if content_type is "text/html" or "text/plain")
          example: "<!doctype html>\n<html class=\"...."
        key:
          type: string
          description: |
            The unique key for the content file (present for all content that is not "text/html" or "text/plain")
          example: "15118724482475bf32615b4a2aaa604fd66377010e"

    # ##############################################
    # SCHEMA EmptyString
    # ##############################################
    EmptyString:
      description: The empty string
      enum:
        - ''
      type: string

    # ##############################################
    # SCHEMA CompanyKey
    # ##############################################
    CompanyKey:
      description: The key for a company
      pattern: ^[0-9]{10}[a-f0-9]{32}$
      example: 156077433683911cdca5fd4563bded979572454cb9
      type: string

    # ##############################################
    # SCHEMA ContentKey
    # ##############################################
    ContentKey:
      description: The key for a content
      pattern: ^[0-9]{10}[a-f0-9]{32}$
      example: 156077433683911cdca5fd4563bded979572454cb9
      type: string

    # ##############################################
    # SCHEMA CompanyType
    # ##############################################
    CompanyType:
      description: |
        The company's/organisation's type

        This is currently based on the registry holding the signatory
        information. Thus `company` really means that Bolagsverket is the
        registry and includes Ekonomiska föreningar as well. For
        `riksidrottsförening` it is Riksindrottsförbundet.
      example: company
      enum:
        - company
        - riksidrottsförening
      type: string

    # ##############################################
    # SCHEMA CompanyName
    # ##############################################
    CompanyName:
      description: The name of a company
      example: Cornelias Café AB
      type: string

    # ##############################################
    # SCHEMA VatNumber
    # ##############################################
    VatNumber:
      pattern: ^[A-Z]{2}[0-9]{10}[0-9]{2}$
      description: |
        The VAT number of the company.

        It follows this format:
        Land code - Organisation number - Serial number
      example: SE556000475501
      type: string

    # ##############################################
    # SCHEMA IncomingEmail
    # ##############################################
    IncomingEmail:
      pattern: ^[a-tv-zA-TV-Z0-9]{9}@(sandbox\.)?kivramail.com$
      description: Email address for receiving emails as content
      type: string
      example: xxcsn2psy@kivramail.com

    # ##############################################
    # SCHEMA ScanningAddress
    # ##############################################
    ScanningAddress:
      description: Postal address for receiving physical mail as scanned content in Kivra.
      nullable: true
      additionalProperties: false
      properties:
        name:
          $ref: '#/components/schemas/CompanyName'
        street:
          description: |
            A special "street" that allows the scanning facility to send to the correct company.

            It's on the format "Kivra: <organisation number>"
          type: string
          example: 'Kivra: 556000-4755'
        postal_code:
          description: |
            The special postal code that goes to Kivra's scanning facility
          example: 106 31
          enum:
            - 106 31
          type: string
        city:
          description: The "city" for Kivra's scanning facility
          example: Stockholm
          enum:
            - Stockholm
          type: string
        country:
          description: The country for Kivra's scanning facility
          example: SE
          enum:
            - SE
          type: string
      required:
        - name
        - street
        - postal_code
        - city
        - country
      type: object

    # ##############################################
    # SCHEMA ScanningFallbackAddress
    # ##############################################
    ScanningFallbackAddress:
      description: If a mailpiece cannot be scanned, it will be forwarded to this address instead.
      nullable: true
      additionalProperties: false
      properties:
        name:
          description: Name of the recipient (a company or person).
          type: string
          example: 'Cornelias Café AB'
        street:
          description: Name of the street, including street number.
          type: string
          example: 'Klara Norra kyrkogata 33'
        postal_code:
          description: Postal code.
          example: '11122'
          type: string
        city:
          description: Name of the city.
          example: 'Stockholm'
          type: string
        country:
          description: Name of the country.
          example: 'Sverige'
          type: string
        care_of:
          description: Address care of (c/o).
          example: ''
          type: string
      required:
        - name
        - street
        - postal_code
        - city
        - country
        - care_of
      type: object

    # ##############################################
    # SCHEMA AllServices
    # ##############################################
    AllServices:
      description: |
        The status of each Kivra Business and Kivra Business Plus service
        for the company.
      additionalProperties: false
      properties:
        email:
          description: Indicates if the Kivra email service is active
          example: false
          type: boolean
        scanning:
          description: Indicates if the scanned mail service is active
          example: false
          type: boolean
        interpreter:
          description: Indicates if the interpreter service is active
          example: false
          type: boolean
        kivra:
          description: Indicates that the Kivra digital mail service is active (always true)
          example: true
          enum:
            - true
          type: boolean
        minameddelanden:
          description: |
            Indicates if the Kivra public authority mail service is active.
          example: true
          type: boolean
      type: object

    # ##############################################
    # SCHEMA FieldQueryParameter
    # ##############################################
    FieldQueryParameter:
      description: The field(s) to respond with
      example: key
      type: string

    # ##############################################
    # SCHEMA BaseCompany
    # ##############################################
    BaseCompany:
      description: A company object with basic fields only
      additionalProperties: false
      properties:
        key:
          $ref: '#/components/schemas/CompanyKey'
        name:
          $ref: '#/components/schemas/CompanyName'
        type:
          $ref: '#/components/schemas/CompanyType'
        vat_number:
          $ref: '#/components/schemas/VatNumber'
      type: object

    # ##############################################
    # SCHEMA FullCompany
    # ##############################################
    FullCompany:
      description: A company object.
      additionalProperties: false
      properties:
        key:
          $ref: '#/components/schemas/CompanyKey'
        scanning_address:
          $ref: '#/components/schemas/ScanningAddress'
        scanning_fallback_address:
          $ref: '#/components/schemas/ScanningFallbackAddress'
        created_at:
          description: When the company started to onboard.
          example: '2019-02-26T14:47:26Z'
          type: string
          format: date-time
        email:
          description: |
            Email address for receiving emails as content.
            Empty if the Kivra email service is not active.
          oneOf:
            - $ref: '#/components/schemas/IncomingEmail'
            - $ref: '#/components/schemas/EmptyString'
        name:
          $ref: '#/components/schemas/CompanyName'
        type:
          $ref: '#/components/schemas/CompanyType'
        services:
          $ref: '#/components/schemas/AllServices'
        vat_number:
          $ref: '#/components/schemas/VatNumber'
      required:
        - key
      type: object

    # ##############################################
    # SCHEMA GovernmentalLabel
    # ##############################################
    GovernmentalLabel:
      description: |
        Indicates if the content comes from a governmental body.
      type: boolean

    # ##############################################
    # SCHEMA HandledLabel
    # ##############################################
    HandledLabel:
      description: |
        The content has been marked as `handled`, previously known as `paid`.
      type: boolean

    # ##############################################
    # SCHEMA InterpretedLabel
    # ##############################################
    InterpretedLabel:
      description: |
        Indicates if the content has been interpreted.
      type: boolean

    # ##############################################
    # SCHEMA ReminderLabel
    # ##############################################
    ReminderLabel:
      description: |
        Indicates if the content, which must be an invoice, is a reminder.
      type: boolean

    # ##############################################
    # SCHEMA TrashedLabel
    # ##############################################
    TrashedLabel:
      description: |
        Indicates if the content has been moved to the trash.
      type: boolean

    # ##############################################
    # SCHEMA ViewedLabel
    # ##############################################
    ViewedLabel:
      description: |
        The content has been viewed. This can be toggled by the user, i.e. "Mark
        as unread".
      type: boolean

    # ##############################################
    # SCHEMA InterpretedFields
    # ##############################################
    InterpretedFields:
      description: |
        Key paths (dot-notation) identifying fields whose values came from the interpreter.
        The paths are relative to the root of the object.
      type: array
      items:
        type: string
      example: ["labels.reminder", "sender_vat_numbers", "type"]

    # ##############################################
    # SCHEMA PartnerPaymentOption
    # ##############################################
    PartnerPaymentOption:
      description: One way to pay this invoice
      additionalProperties: false
      properties:
        account:
          description: The account to pay to
          example: '12345678'
          type: string
          nullable: true
        amount:
          minimum: 0
          description: The amount to pay in öre, or equivalent
          example: 150000
          type: integer
          nullable: true
        currency:
          description: The currency used for this payment option
          example: SEK
          type: string
          nullable: true
        description:
          description: The description of this payment option
          example: 12 month subscription
          type: string
          nullable: true
        due_at:
          description: Due date of this payment option
          example: '2022-03-30T00:00:00Z'
          type: string
          format: date-time
          nullable: true
        interpreted:
          description: True if and only if this payment option was interpreted
          example: true
          type: boolean
        reference:
          description: |
            The payments reference, could be an OCR number or invoice reference
          example: 987654321
          type: string
          nullable: true
        reference_type:
          description: The type of reference
          example: OCR
          type: string
          nullable: true
        type:
          description: The type of the the payment, aka the type of the account
          example: bankgiro
          type: string
          nullable: true
        vat_amount:
          description: The VAT in öre for this invoice, if available
          example: 1500
          type: integer
          nullable: true
      required:
        - account
        - amount
        - currency
        - description
        - due_at
        - interpreted
        - reference
        - reference_type
        - type
        - vat_amount
      type: object

    # ##############################################
    # SCHEMA InvoiceReferences
    # ##############################################
    InvoiceReferences:
      description: References for this invoice
      additionalProperties: false
      nullable: true
      properties:
        our:
          description: Our reference, "vår referens" in Swedish
          type: string
          nullable: true
          example: "Gustav Larsson"
        your:
          description: Your reference, "er referens" in Swedish
          type: string
          nullable: true
          example: null
      required:
        - our
        - your
      type: object

    # ##############################################
    # SCHEMA PartQueryParameter
    # ##############################################
    PartQueryParameter:
      minimum: 1
      description: The content part to retrive, 1-indexed
      type: integer

    # ##############################################
    # SCHEMA PartMetadata
    # ##############################################
    PartMetadata:
      additionalProperties: false
      properties:
        content_type:
          description: The MIME type of this content part
          enum:
            - application/pdf
            - text/html
            - text/plain
            - image/jpeg
            - image/gif
            - image/png
            - text/calendar
            - application/msword
            - >-
              application/vnd.openxmlformats-officedocument.wordprocessingml.document
            - >-
              application/vnd.openxmlformats-officedocument.wordprocessingml.template
          type: string
        name:
          description: The name of this content part. Usually a filename.
          type: string
          example: faktura.pdf
        sha256:
          description: The SHA256 digest of this content part
          type: string
          example: 060bed374498fe2f36a5f2e1abf217a90beb46e8fe4ec1d9d5ce7746
        size:
          minimum: 0
          description: The size in bytes of this content part
          type: integer
          example: 4711
        url:
          description: The URL to fetch this content part
          type: string
          example: "https://sender.sandbox-api.kivra.com/v3/partner/company/1691677086a57b73569d594df5abad7fd2575c1070/content/1691677075a9813e08f783496382b0bff743ec34ae?part=1"
      required:
        - content_type
        - name
        - sha256
        - size
        - url
      type: object

    # ##############################################
    # SCHEMA ContentPart
    # ##############################################
    ContentPart:
      description: |
       The file data of the content part, `content_type` in the part metadata
       describes its file type.

    # ##############################################
    # SCHEMA BaseContentMetadata
    # ##############################################
    BaseContentMetadata:
      description: Listing summary of content metadata
      additionalProperties: false
      properties:
        created_at:
          description: |
            This is the same date and time as `transaction_at`, except for
            reminder invoices, where it is the reminder date and not the
            original invoice date.
          type: string
          format: date-time
          nullable: false
        key:
          $ref: '#/components/schemas/ContentKey'
        labels:
          description: The labels that apply to this content
          additionalProperties: false
          properties:
            governmental:
              $ref: '#/components/schemas/GovernmentalLabel'
            handled:
              $ref: '#/components/schemas/HandledLabel'
            interpreted:
              $ref: '#/components/schemas/InterpretedLabel'
            reminder:
              $ref: '#/components/schemas/ReminderLabel'
            trashed:
              $ref: '#/components/schemas/TrashedLabel'
            viewed:
              $ref: '#/components/schemas/ViewedLabel'
          required:
            - governmental
            - handled
            - interpreted
            - reminder
            - trashed
            - viewed
          type: object
        parts:
          type: array
          items:
            $ref: '#/components/schemas/PartMetadata'
        received_at:
          description: When the content was received by Kivra
          type: string
          format: date-time
        receiver_name:
          description: The name of the recipient company
          type: string
          example: Developers Developers Developers AB
        receiver_vat_number:
          $ref: '#/components/schemas/VatNumber'
        sender_icon_url:
          type: string
          example: "https://sandbox-static.kivra.com/img/tenant/1341573157b3a1c55f220f4007b2e44789d2d04015/icon.png"
          format: url
          description: A url to the icon used by the sender within Kivra, or `null` if no corresponding icon exists.
          nullable: true
        sender_name:
          description: The name of the sender
          example: Lenas Konditori AB
          type: string
          nullable: true
        sender_vat_numbers:
          description: VAT numbers representing the sender
          type: array
          items:
            $ref: '#/components/schemas/VatNumber'
          nullable: true
        subject:
          description: Subject of the content
          example: "Invoice: a thousand Swiss rolls"
          type: string
        transaction_at:
          description: |
            The date and time this content conceptually took place.

            + For a normal `invoice` it is the invoice date.
            + For a reminder `invoice` it the original invoice date and not
              the reminders invoice date.
            + For a `receipt` it is its transaction date.
            + For all `other` types of content it is `null`.
            + If no date could be found, it is `null`.
          type: string
          format: date-time
          nullable: true
        type:
          description: The type of the content
          enum:
            - invoice
            - receipt
            - other
          type: string
      required:
        - created_at
        - key
        - labels
        - parts
        - received_at
        - receiver_name
        - receiver_vat_number
        - sender_icon_url
        - sender_name
        - sender_vat_numbers
        - subject
        - transaction_at
        - type
      type: object

    # ##############################################
    # SCHEMA FullContentMetadata
    # ##############################################
    FullContentMetadata:
      description: Details of content metadata
      allOf:
        - type: object
          properties:
            interpreted_fields:
              $ref: '#/components/schemas/InterpretedFields'
            parts:
              description: The files in the content
              type: array
              items:
                $ref: '#/components/schemas/PartMetadata'
            payment_options:
              description: Different ways to pay an invoice
              type: array
              items:
                $ref: '#/components/schemas/PartnerPaymentOption'
            references:
              $ref: '#/components/schemas/InvoiceReferences'
          required:
            - interpreted_fields
            - key
            - labels
            - parts
            - payment_options
            - references
            - received_at
            - receiver_name
            - receiver_vat_number
            - sender_icon_url
            - sender_name
            - sender_vat_numbers
            - subject
            - transaction_at
            - type
        - $ref: '#/components/schemas/BaseContentMetadata'

  # ##############################################
  # SECURITY oAuth2Client
  # ##############################################

  securitySchemes:
    oAuth2Client:
      type: oauth2
      flows:
        clientCredentials:
          tokenUrl: "https://sender.api.kivra.com/v1/auth"
